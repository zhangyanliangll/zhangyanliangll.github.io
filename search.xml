<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flutter 环境安装</title>
    <url>/post/bcc329f.html</url>
    <content><![CDATA[<h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><blockquote>
<p>Flutter 的魅力之一是开源开放，Flutter 由 Google 主导，与全球的开发者共同协作,有无限接近原生的性能。</p>
</blockquote>
<h2 id="Flutter-SDK"><a href="#Flutter-SDK" class="headerlink" title="Flutter SDK"></a>Flutter SDK</h2><h3 id="通过-git-方式获取-推荐此方式"><a href="#通过-git-方式获取-推荐此方式" class="headerlink" title="通过 git 方式获取 (推荐此方式)"></a>通过 git 方式获取 <code>(推荐此方式)</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/flutter/flutter.git -b stable</span><br></pre></td></tr></table></figure>

<h2 id="将-Flutter-添加全局环境变量"><a href="#将-Flutter-添加全局环境变量" class="headerlink" title="将 Flutter 添加全局环境变量"></a>将 Flutter 添加全局环境变量</h2><ul>
<li>复制下面文本</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#setup flutter 镜像</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line"></span><br><span class="line">#配置本地 Flutter SDK 地址</span><br><span class="line">export FLUTTER_HOME=/Users/mr.zhang/flutter/bin</span><br><span class="line">export PATH=$PATH:$&#123;FLUTTER_HOME&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><span class='error'>注意：</span> <code>mr.zhang</code> 是你自己的用户名地址</p>
</li>
<li><p>在控制台执行下面命令，把上面文本复制进去，保存，退出</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open ~/.zshrc</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/647b057346c52.jpg" alt="image-20190703134312917"></p>
<ul>
<li>执行下面命令使刚配置的环境变量生效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<h2 id="Flutter-doctor"><a href="#Flutter-doctor" class="headerlink" title="Flutter doctor"></a>Flutter doctor</h2><h3 id="运行以下命令查看是否需要安装其它依赖"><a href="#运行以下命令查看是否需要安装其它依赖" class="headerlink" title="运行以下命令查看是否需要安装其它依赖:"></a>运行以下命令查看是否需要安装其它依赖:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure>

<h3 id="如果是报这个错，cocoapods-未安装，依次执行下面顺序"><a href="#如果是报这个错，cocoapods-未安装，依次执行下面顺序" class="headerlink" title="如果是报这个错，cocoapods 未安装，依次执行下面顺序"></a>如果是报这个错，cocoapods 未安装，依次执行下面顺序</h3><p><img src="https://www.hualigs.cn/image/647b0a66ee8b2.jpg" alt="image-20190703134312917"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gem install activesupport -v 6.1.7.3</span><br><span class="line"></span><br><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<h3 id="在通过下面命令查询，看是装成功"><a href="#在通过下面命令查询，看是装成功" class="headerlink" title="在通过下面命令查询，看是装成功"></a>在通过下面命令查询，看是装成功</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gem list</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/647b0b14611cc.jpg" alt="image-20190703134312917"></p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://www.hualigs.cn/image/647b0bf93b186.jpg" alt="image-20190703134312917"></p>
<blockquote>
<p>最后，感谢你的观看 🙏，祝你成功</p>
</blockquote>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>整理一些 Vue3 常用Api</title>
    <url>/post/0.html</url>
    <content><![CDATA[<blockquote>
<p>记录 Vue3 中一些常用的 Api<br></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自己开发 <code>Vue3</code> 也有好几个项目了，闲来之下整理一下常用的 Api 方法，本文会介绍 <code>Vue3</code> 常用的 Api 使用，希望能帮助到大家，同时算是自己的一种总结吧，如有问题，请及时联系我，十分欢迎各位大佬的指正。</p>
<h2 id="1、ref"><a href="#1、ref" class="headerlink" title="1、ref"></a>1、ref</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>定义一个响应式的数据，一般来说定义一个基本数据类型会用 <code>ref</code>，<code>(Undefined、Null、Boolean、Number、String)</code></p>
<ul>
<li><p>基本数据类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// ref用于定义一个响应式的数据，返回的是一个RefImpl对象，对象中有一个value属性</span></span><br><span class="line"><span class="comment">// 如果需要对数据进行操作，需要使用该RefImpl对象的value属性</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  count.<span class="property">value</span>++;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象数据类型（不一般的情况）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; obj.count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  obj.<span class="property">value</span>.<span class="property">count</span>++;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">value</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们打印这两种数据会发现，通过<code>ref</code>响应的<code>对象数据类型</code>，<code>_value</code>变成了<code>Proxy</code>实例对象，这是因为<code>vue3</code>底层会把<code>ref</code>中的对象都变成<code>Proxy</code>实例对象，对于基本数据类型就是按照<code>Object.defineProperty</code>里面的<code>get</code>和<code>set</code>进行数据劫持然后进行响应式，但是如果是对象类型的话，是用到的<code>Proxy</code>，vue3 把这个函数封装在了<code>reactive</code>里，就是如果<code>ref</code>中是对象的话，会自动调用<code>reactive</code>。</p>
<p><span class='error'>注意：</span> <code>script</code> 中操作数据需要使用<code>xxx.value</code>的形式，而模板中不需要添加<code>.value</code></p>
<h4 id="去掉-value"><a href="#去掉-value" class="headerlink" title="去掉 .value"></a>去掉 <code>.value</code></h4><p>即 vue3 提了一个 Ref Sugar 的 RFC，即 ref 语法糖，在 ref 前加上$，目前还处理实验阶段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(&#123;</span><br><span class="line">      <span class="attr">refTransform</span>: <span class="literal">true</span>, <span class="comment">// 开启 ref 转换 , 开启之后就不需要 .value 了可以直接使用</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .vue 文件中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> count = $ref(<span class="number">0</span>); <span class="keyword">const</span> <span class="title function_">addCount</span> = (<span class="params"></span>) =&gt; &#123;count++&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2、reactive"><a href="#2、reactive" class="headerlink" title="2、reactive"></a>2、reactive</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>定义对象类型的响应式数据，接收一个普通对象然后返回该普通对象的响应式代理器对象(<code>Proxy</code>)，它会影响到所有嵌套的属性，也可以进行数组的响应式。一个响应式对象也将深层地解包任何 <code>ref</code> 属性，同时保持响应性。若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 <code>shallowReactive()</code> 作替代。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名：&#123;&#123; detail.name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>年龄：&#123;&#123; detail.age &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;editInfo&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 深层次响应</span></span><br><span class="line"><span class="keyword">const</span> detail = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">editInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  detail.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">  detail.<span class="property">age</span> = <span class="string">&#x27;20&#x27;</span></span><br><span class="line">  <span class="comment">// 会更新 detail</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(detail.<span class="property">name</span>) <span class="comment">// 李四</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(detail.<span class="property">age</span>) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>前面说<code>ref</code>可以响应，每次需要<code>.value</code>就是，可能有人觉的好用吧，只要<code>.value</code>就可以了，他喵的，正常点，我可不想以后碰到你的代码 😭，因为一旦页面数据多起来，不得把<code>.value</code>点冒烟了。</p>
<p><span class='error'>注意：</span> <code>reactive</code> 的弊端是不能解构，解构就会失去响应性，当然你也可以用 <code>toRefs</code> 来解决这个问题</p>
<h2 id="3、computed"><a href="#3、computed" class="headerlink" title="3、computed"></a>3、computed</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面会继续更新…</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>ES5</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Arc浏览器</title>
    <url>/post/22b39f77.html</url>
    <content><![CDATA[<h1 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a><a href="https://arc.net/privacy">Arc</a></h1><blockquote>
<p>Arc 有很多快捷键，很利于开发人员开发使用这个浏览器，Tab 在浏览器的左边，不像谷歌在顶部，如果你打开 20 几个标签，像谷歌的话你只能一个一个重新打开去查找，而 Arc 它在左边侧边栏，是非常喜欢的一个点。还有就是可以分页，两个页面进行对比啥之类，空间 space，很多功能，我用其他功能也不多，有兴趣的就自己研究吧。<br>对于新手，你之前不管是谷歌还是火狐等，之前的数据书签你都可以进行一健导入。</p>
</blockquote>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><ul>
<li><code>Command + L</code>: 打开 Command bar</li>
<li><code>Command + T</code>: 打开 Command bar 输入后跳入到新页面</li>
<li><code>Command + S</code>: 关闭&#x2F;打开侧边栏，这个本来我想改成 <code>Command + B</code> 和 <code>vscode</code> 一样的但是不知道为什么改不动</li>
<li><code>Command + W</code>: 关掉当前页面</li>
<li><code>Command + R</code>: 刷新当前页面</li>
<li><code>Command + Shift + R</code>: 清楚缓存刷新</li>
<li><code>Command + Shift + K</code>: 关掉当前 Space 所有未固定的页面</li>
<li><code>Command + Y</code>: 浏览历史记录</li>
<li><code>Command + Option + N</code>: 新开一个小窗搜索页面</li>
<li><code>Command + Shift + C</code>: 复制当前页面 URL</li>
<li><code>Command + Option + Shift + C</code>: 复制当前页面 URL 为 Markdown 的链接格式，这个写博客或者做汇报很有用</li>
<li><code>Control + Shift + =</code>: 在当前页面创建一个新页面并分屏当前页面，我把 vscdoe 向右拆分改成和这个一样的</li>
<li><code>Command + Shift + 2</code>: 网页截屏</li>
<li><code>Command + [</code>: 回退</li>
<li><code>Command + ]</code>: 前进</li>
<li><code>Command + Number</code>: Number 代表数字变量，跳转对应的侧边栏第几个</li>
<li><code>Command + Q</code>: 退出Arc</li>
<li><code>Command + Shift + =</code>: 当前页面放大</li>
<li><code>Command + Shift + -</code>: 当前页面缩小</li>
<li><code>Command + Q</code>: 退出Arc</li>
</ul>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><ul>
<li><code>Control + H</code>: 隐藏当前窗口</li>
<li><code>Command + N</code>: 新开一个窗口</li>
</ul>
<h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><ul>
<li><code>Command + Option + I</code>: 控制台显示隐藏</li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Arc</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 响应式解决方案</title>
    <url>/post/26077e3f.html</url>
    <content><![CDATA[<h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><blockquote>
<p>响应式解决方案（Responsive Design）是为了使网站或应用程序能够适应不同设备的屏幕大小和分辨率，提供一致、优化的用户体验的设计方法。它通过 CSS 的灵活布局、媒体查询和可伸缩的图像等技术，确保在手机、平板、桌面等不同设备上都能正常显示。</p>
</blockquote>
<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><ul>
<li><a href="https://github.com/cuth/postcss-pxtorem">postcss-pxtorem</a> 插件转化 Rem 单位设置字体大小，使文字根据屏幕大小缩放。</li>
<li><a href="https://www.tailwindcss.cn/">Tailwindcss</a></li>
<li>css 媒体查询 @media</li>
</ul>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>新建 <code>media.scss</code> 文件：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$breakpoints</span>: (</span><br><span class="line">  <span class="string">&#x27;phone&#x27;</span>: ( // 手机端</span><br><span class="line">    <span class="number">320px</span>,</span><br><span class="line">    <span class="number">480px</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">&#x27;pad&#x27;</span>: ( // ipad</span><br><span class="line">    <span class="number">481px</span>,</span><br><span class="line">    <span class="number">768px</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">&#x27;notebook&#x27;</span>: ( // 笔记本</span><br><span class="line">    <span class="number">769px</span>,</span><br><span class="line">    <span class="number">1024px</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">&#x27;desktop&#x27;</span>: ( // 电脑</span><br><span class="line">    <span class="number">1025px</span>,</span><br><span class="line">    <span class="number">1200px</span>,</span><br><span class="line">  ),</span><br><span class="line">  <span class="string">&#x27;tv&#x27;</span>: <span class="number">1021px</span>, // 电视</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> respond-to(<span class="variable">$breakname</span>) &#123;</span><br><span class="line">  <span class="variable">$bp</span>: <span class="built_in">map-get</span>(<span class="variable">$breakpoints</span>, <span class="variable">$breakname</span>);</span><br><span class="line">  <span class="keyword">@if</span> type-of(<span class="variable">$bp</span>) == <span class="string">&#x27;list&#x27;</span> &#123;</span><br><span class="line">    <span class="variable">$min</span>: <span class="variable">$nth</span>(<span class="variable">$bp</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="variable">$max</span>: <span class="variable">$nth</span>(<span class="variable">$bp</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">$min</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="variable">$max</span>) &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">$bp</span>) &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>viteconfig.ts：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">`@import &quot;@/styles/scss/media.scss&quot;;`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列子："><a href="#列子：" class="headerlink" title="列子："></a>列子：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home-page&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当屏幕宽度小于 640px 时，背景为蓝色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当屏幕宽度在 1025px 及 1200px时，背景变为红色 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.home-page</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="keyword">@include</span> respond-to(<span class="string">&#x27;desktop&#x27;</span>) &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@include</span> respond-to(<span class="string">&#x27;mobile&#x27;</span>) &#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>pnpm下载 tailwindcss，<a href="https://www.tailwindcss.cn/">文档</a></p>
<p>新建 <code>tailwind.config</code> 文件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="attr">extend</span>: &#123;</span><br><span class="line">      <span class="attr">screens</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;sm&#x27;</span>: <span class="string">&#x27;640px&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;md&#x27;</span>: <span class="string">&#x27;768px&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;lg&#x27;</span>: <span class="string">&#x27;1024px&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xl&#x27;</span>: <span class="string">&#x27;1280px&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="列子：-1"><a href="#列子：-1" class="headerlink" title="列子："></a>列子：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg-blue-500 sm:bg-green-500 lg:bg-red-500&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当屏幕宽度小于 640px 时，背景为蓝色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当屏幕宽度在 640px 及以上时，背景变为绿色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当屏幕宽度在 1024px 及以上时，背景变为红色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5严格模式相关</title>
    <url>/post/e9d35568.html</url>
    <content><![CDATA[<h1 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h1><blockquote>
<p>ECMAScript 5 最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。<br>理解严格模式的规则非常重要，ECMAScript 的下一个版本将以严格模式为基础制定。支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+和 Chrome</p>
</blockquote>
<h2 id="严格模式的作用"><a href="#严格模式的作用" class="headerlink" title="严格模式的作用"></a>严格模式的作用</h2><ul>
<li>消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的 JavaScript 做好铺垫</li>
</ul>
<h2 id="严格模式的开启"><a href="#严格模式的开启" class="headerlink" title="严格模式的开启"></a>严格模式的开启</h2><p>想要开启严格模式，直接在作用域开始的位置写上字符串 “use strict”;</p>
<p>在全局模式下开启：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在局部模式下开启（在函数中打开严格模式）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// more codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="严格模式特点："><a href="#严格模式特点：" class="headerlink" title="严格模式特点："></a>严格模式特点：</h2><h2 id="一、将过失转化成异常"><a href="#一、将过失转化成异常" class="headerlink" title="一、将过失转化成异常"></a>一、将过失转化成异常</h2><p>在严格模式下, 某些先前被接受的过失错误将会被认为是异常. JavaScript 被设计为能使新人开发者更易于上手, 所以有时候会给本来错误操作赋予新的不报错误的语义(non-error semantics). 有时候这可以解决当前的问题, 但有时候却会给以后留下更大的问题. 严格模式则把这些失误当成错误, 以便可以发现并立即将其改正.</p>
<h3 id="1、严格模式下无法再意外创建全局变量"><a href="#1、严格模式下无法再意外创建全局变量" class="headerlink" title="1、严格模式下无法再意外创建全局变量"></a>1、严格模式下无法再意外创建全局变量</h3><blockquote>
<p>普通的 JavaScript 里面给一个错误命名的变量名赋值会使全局对象新增一个属性并继续“工作”（尽管将来可能会失败：在现代的 JavaScript 中有可能）。严格模式中意外创建全局变量被抛出错误替代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 假如有一个全局变量叫做mistypedVariable</span></span><br><span class="line">mistypedVaraible = <span class="number">17</span>; <span class="comment">// 因为变量名拼写错误</span></span><br><span class="line"><span class="comment">// 这一行代码就会抛出 ReferenceError</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2、静默失败的赋值操作抛出异常"><a href="#2、静默失败的赋值操作抛出异常" class="headerlink" title="2、静默失败的赋值操作抛出异常"></a>2、静默失败的赋值操作抛出异常</h3><ul>
<li>严格模式会使引起静默失败的赋值操作抛出异常</li>
</ul>
<blockquote>
<p>静默失败是指不报错也没有任何效果</p>
<p>NaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常. 任何在正常模式下引起静默失败的赋值操作 (给不可写属性赋值, 给只读属性(getter-only)赋值, 给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可写属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj1, <span class="string">&quot;x&quot;</span>, &#123; <span class="attr">value</span>: <span class="number">42</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">obj1.<span class="property">x</span> = <span class="number">9</span>; <span class="comment">// 抛出TypeError错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给只读属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj2.<span class="property">x</span> = <span class="number">5</span>; <span class="comment">// 抛出TypeError错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可扩展对象的新属性赋值</span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(fixed);</span><br><span class="line">fixed.<span class="property">newProp</span> = <span class="string">&quot;ohai&quot;</span>; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3、删除不可删除的属性时会抛出异常"><a href="#3、删除不可删除的属性时会抛出异常" class="headerlink" title="3、删除不可删除的属性时会抛出异常"></a>3、删除不可删除的属性时会抛出异常</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>

<h3 id="4、一个对象内的所有属性名在对象内必须唯一"><a href="#4、一个对象内的所有属性名在对象内必须唯一" class="headerlink" title="4、一个对象内的所有属性名在对象内必须唯一"></a>4、一个对象内的所有属性名在对象内必须唯一</h3><blockquote>
<p>正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码要去改变属性值而不是修改最后一个重名属性的时候，复制这个对象就产生一连串的 bug。在严格模式下，重名属性被认为是语法错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">1</span>, <span class="attr">p</span>: <span class="number">2</span> &#125;; <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5、函数的参数名唯一"><a href="#5、函数的参数名唯一" class="headerlink" title="5、函数的参数名唯一"></a>5、函数的参数名唯一</h3><blockquote>
<p>正常模式下, 最后一个重名参数名会掩盖之前的重名参数. 之前的参数仍然可以通过 <code>arguments[i] 来访问</code>, 还不是完全无法访问. 然而, 这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了), 所以在严格模式下重名参数被认为是语法错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, a, c</span>) &#123;</span><br><span class="line">  <span class="comment">// !!! 语法错误</span></span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> a + a + c; <span class="comment">// 代码运行到这里会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6、禁止八进制数字语法"><a href="#6、禁止八进制数字语法" class="headerlink" title="6、禁止八进制数字语法"></a>6、禁止八进制数字语法</h3><blockquote>
<p>ECMAScript 并不包含八进制语法, 但所有的浏览器都支持这种以零(<code>0</code>)开头的八进制语法: <code>0644 === 420</code> 还有 <code>&quot;\045&quot; === &quot;%&quot;</code>.在 ECMAScript 6 中支持为一个数字加”<code>0</code>o”的前缀来表示八进制数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 0o10; // ES6: 八进制</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7、禁止设置-primitive-值的属性"><a href="#7、禁止设置-primitive-值的属性" class="headerlink" title="7、禁止设置 primitive 值的属性"></a>7、禁止设置 primitive 值的属性</h3><blockquote>
<p>ECMAScript 6 中的严格模式禁止设置<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">primitive</a>值的属性.不采用严格模式,设置属性将会简单忽略(no-op),采用严格模式,将抛出<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError">TypeError</a>错误</p>
<p>primitive 指的是原始的，也就是基本数据类型</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="literal">false</span>.<span class="property">true</span> = <span class="string">&quot;&quot;</span>; <span class="comment">//TypeError</span></span><br><span class="line">  (<span class="number">14</span>).<span class="property">sailing</span> = <span class="string">&quot;home&quot;</span>; <span class="comment">//TypeError</span></span><br><span class="line">  <span class="string">&quot;with&quot;</span>.<span class="property">you</span> = <span class="string">&quot;far away&quot;</span>; <span class="comment">//TypeError</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、简化变量的使用"><a href="#二、简化变量的使用" class="headerlink" title="二、简化变量的使用"></a>二、简化变量的使用</h2><p>严格模式简化了代码中变量名字映射到变量定义的方式. 很多编译器的优化是依赖存储变量 X 位置的能力：这对全面优化 JavaScript 代码至关重要. JavaScript 有些情况会使得代码中名字到变量定义的基本映射只在运行时才产生. 严格模式移除了大多数这种情况的发生, 所以编译器可以更好的优化严格模式的代码.</p>
<h3 id="1、禁用-with"><a href="#1、禁用-with" class="headerlink" title="1、禁用 with"></a>1、禁用 with</h3><p>with 所引起的问题是块内的任何名称可以映射(map)到 with 传进来的对象的属性, 也可以映射到包围这个块的作用域内的变量(甚至是全局变量), 这一切都是在运行时决定的: 在代码运行之前是无法得知的. 严格模式下, 使用 with 会引起语法错误, 所以就不会存在 with 块内的变量在运行时才决定引用到哪里的情况了:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">with</span> (&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="title function_">with</span> (&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//SyntaxError !!! 语法错误</span></span><br><span class="line">    <span class="comment">// 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？</span></span><br><span class="line">    <span class="comment">// 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="2、禁止删除声明变量"><a href="#2、禁止删除声明变量" class="headerlink" title="2、禁止删除声明变量"></a>2、禁止删除声明变量</h2><p><code>delete name</code> 在严格模式下会引起语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// !!! 语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var y; delete y;&quot;</span>); <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<h3 id="3、arguments-变为参数的静态副本"><a href="#3、arguments-变为参数的静态副本" class="headerlink" title="3、arguments 变为参数的静态副本"></a>3、arguments 变为参数的静态副本</h3><p>非严格模式下，arguments 对象里的元素和对应的参数是指向同一个值的<code>引用</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//100</span></span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//1</span></span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>但是：传的<code>参数</code>是<code>对象</code>除外。arguments 和形参共享传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>); <span class="comment">//1</span></span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>].<span class="property">x</span> = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>); <span class="comment">//100</span></span><br><span class="line">&#125;)(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4、eval-变成独立作用域"><a href="#4、eval-变成独立作用域" class="headerlink" title="4、eval 变成独立作用域"></a>4、eval 变成独立作用域</h3><p>在正常模式下, 代码 eval(“var x;”) 会给上层函数(surrounding function)或者全局引入一个新的变量 x . 这意味着, 一般情况下, 在一个包含 eval 调用的函数内所有没有引用到参数或者局部变量的名称都必须在运行时才能被映射到特定的定义 (因为 eval 可能引入的新变量会覆盖它的外层变量). 在严格模式下 eval 仅仅为被运行的代码创建变量, 所以 eval 不会使得名称映射到外部变量或者其他局部变量:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;var evalVal = 2;&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> evalVal); <span class="comment">//number</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;var evalVal = 2;&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> evalVal); <span class="comment">//undefined</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="5、不再支持-arguments-callee"><a href="#5、不再支持-arguments-callee" class="headerlink" title="5、不再支持 arguments.callee"></a>5、不再支持 arguments.callee</h3><p>正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为 arguments.callee 会依赖对非内联函数的引用。在严格模式下，arguments.callee 是一个不可删除属性，而且赋值和读取时都会抛出异常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 抛出类型错误</span></span><br></pre></td></tr></table></figure>

<h4 id="6、this-指向-undefined"><a href="#6、this-指向-undefined" class="headerlink" title="6、this 指向 undefined"></a>6、this 指向 undefined</h4><p>一般函数调用(不是对象的方法调用，也不使用 apply&#x2F;call&#x2F;bind 等修改 this)，this 指向 undefined，而不是全局对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun</span>()); <span class="comment">//Window</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fun</span>()); <span class="comment">//undefined</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/post/af3eed3c.html</url>
    <content><![CDATA[<blockquote>
<p>关于 HTTP 协议相关</p>
</blockquote>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>协议规定了浏览器和万维网服务器之间互相通信的规则,约定</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>重点是格式和参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行包括三部分：请求类型、url路径、HTTP协议版本</span></span><br><span class="line">行 <span class="variable constant_">POST</span> s?wd=http&amp;rsv_spt=<span class="number">1</span></span><br><span class="line">头 <span class="attr">HOST</span>: atguigu.<span class="property">com</span></span><br><span class="line">   <span class="title class_">Cookie</span>: name=guigu</span><br><span class="line">   <span class="title class_">Content</span>-<span class="attr">type</span>: applicaion/x-www-form-urlencoded</span><br><span class="line">   <span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">63</span></span><br><span class="line"><span class="comment">//空行是固定的，必须有</span></span><br><span class="line">空行</span><br><span class="line"><span class="comment">//请求体可以有，可以没有，如果是GET，请求体是空的，如果是POST,请求体可以不为空</span></span><br><span class="line">体 username=admin&amp;password=admin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行包括三部分：HTTP协议版本、响应状态码、响应状态字符串</span></span><br><span class="line">行 <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line">头 <span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line">   <span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line">   <span class="title class_">Content</span>-<span class="attr">encoding</span>:gzip</span><br><span class="line">空行</span><br><span class="line">体 &lt;html&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>小皮<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">   &lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的难点重点</title>
    <url>/post/398dfb6f.html</url>
    <content><![CDATA[<blockquote>
<p>记录 JS 中重点难点知识点，特别是面试必问的原理点<br></p>
</blockquote>
<h1 id="一、JS-基础总结"><a href="#一、JS-基础总结" class="headerlink" title="一、JS 基础总结"></a>一、JS 基础总结</h1><h2 id="01-JS-基础总结"><a href="#01-JS-基础总结" class="headerlink" title="01 JS 基础总结"></a>01 JS 基础总结</h2><h3 id="1）基本类型"><a href="#1）基本类型" class="headerlink" title="1）基本类型:"></a>1）基本类型:</h3><ul>
<li>String: 任意字符串</li>
<li>Number: 任意的数字</li>
<li>boolean: true&#x2F;false</li>
<li>undefined: undefined</li>
<li>null: null</li>
</ul>
<h3 id="2）对象（引用）类型"><a href="#2）对象（引用）类型" class="headerlink" title="2）对象（引用）类型"></a>2）对象（引用）类型</h3><ul>
<li>Object: 任意对象</li>
<li>Function：一种特别的对象（可以执行）</li>
<li>Array：一种特别的对象（数值下标，内部数据是有序的）</li>
</ul>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><ul>
<li><p>可以判断 undefined、数值、字符串、boolean 值、function</p>
</li>
<li><p>不能判断：null 与 object object 与 array(因为 typeof 返回了 object，无法判断为数组)</p>
<p>事实上，typeof 对于 null、object 和 array 都是返回 object</p>
<p>返回数据类型的字符串表达</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="keyword">typeof</span> a) <span class="comment">//undefined &#x27;undefined&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> a = <span class="string">&#x27;undefined&#x27;</span> ,a = <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">//undefined &#x27;undefined&#x27; true true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> = <span class="string">&#x27;undefined&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul>
<li>判断对象的具体类型</li>
<li>B instanceof A &#x2F;&#x2F;判断 B 是否是 A 的实例</li>
</ul>
<h4 id="不会做数据转换"><a href="#不会做数据转换" class="headerlink" title="&#x3D; (不会做数据转换)"></a>&#x3D; (不会做数据转换)</h4><ul>
<li>可以判断：undefined, null</li>
</ul>
<h3 id="重点问题："><a href="#重点问题：" class="headerlink" title="重点问题："></a>重点问题：</h3><h4 id="1、undefined-与-null-区别？"><a href="#1、undefined-与-null-区别？" class="headerlink" title="1、undefined 与 null 区别？"></a>1、undefined 与 null 区别？</h4><ul>
<li><p>undefined 代表定义了未赋值</p>
</li>
<li><p>null 定义了并且赋值了 null</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//undefined</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h4 id="2、什么时候给变量赋值-null"><a href="#2、什么时候给变量赋值-null" class="headerlink" title="2、什么时候给变量赋值 null?"></a>2、什么时候给变量赋值 null?</h4><ul>
<li><p>初始赋值，表明将要赋值为对象</p>
</li>
<li><p>结束前赋值，让对象成为垃圾对象（被垃圾回收期回收）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>; <span class="comment">//初始赋值为null,表明将要赋值为对象</span></span><br><span class="line">b = <span class="string">&quot;pika&quot;</span>; <span class="comment">//确定对象就赋值</span></span><br><span class="line"><span class="comment">//最后</span></span><br><span class="line">b = <span class="literal">null</span>; <span class="comment">//让b指向的对象成为垃圾对象（被垃圾回收器回收 ）</span></span><br></pre></td></tr></table></figure>

<h4 id="3、怎么样严格区分变量类型和数据类型？"><a href="#3、怎么样严格区分变量类型和数据类型？" class="headerlink" title="3、怎么样严格区分变量类型和数据类型？"></a>3、怎么样严格区分变量类型和数据类型？</h4><ul>
<li><p>数据的类型</p>
<ul>
<li>基本类型</li>
<li>对象类型</li>
</ul>
</li>
<li><p>变量的类型（变量内存值的类型，变量本身是没有类型的）</p>
<ul>
<li><p>基本类型：保存的是基本类型的数据</p>
</li>
<li><p>引用类型：保存的是地址值</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给变量c赋值</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c); <span class="comment">// 输出&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="02-数据-变量-内存"><a href="#02-数据-变量-内存" class="headerlink" title="02 数据_变量_内存"></a>02 数据_变量_内存</h2><h3 id="重点问题：-1"><a href="#重点问题：-1" class="headerlink" title="重点问题："></a>重点问题：</h3><h4 id="1、什么是数据？"><a href="#1、什么是数据？" class="headerlink" title="1、什么是数据？"></a>1、什么是数据？</h4><ul>
<li><p>存储在内存中代表特定信息的’东东’，本质上是 0101…..</p>
<h5 id="数据的特点：可传递，可运算"><a href="#数据的特点：可传递，可运算" class="headerlink" title="数据的特点：可传递，可运算"></a>数据的特点：可传递，可运算</h5><h5 id="一切皆数据"><a href="#一切皆数据" class="headerlink" title="一切皆数据"></a>一切皆数据</h5><h5 id="内存中所有操作的目标：数据"><a href="#内存中所有操作的目标：数据" class="headerlink" title="内存中所有操作的目标：数据"></a>内存中所有操作的目标：数据</h5><ul>
<li>算术运算</li>
<li>逻辑运算</li>
<li>数值</li>
<li>运行函数</li>
</ul>
</li>
</ul>
<h4 id="2、什么是内存？"><a href="#2、什么是内存？" class="headerlink" title="2、什么是内存？"></a>2、什么是内存？</h4><ul>
<li><p>内存条通电后产生的可储存数据的空间</p>
</li>
<li><p>内存产生和死亡：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">内存条（电路板）-&gt; 通电 -&gt; 产生内存空间 -&gt; 存储数据 -&gt; 处理数据 -&gt; 断电 -&gt; 内存空间和数据都消失</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一块小内存的 2 个数据 （标识+存储的数据，比如：obj:0x123）</p>
<ul>
<li>内部存储的数据</li>
<li>地址值</li>
</ul>
</li>
<li><p>内存分类</p>
<ul>
<li>栈 ：局部变量和全局变量</li>
<li>堆：对象</li>
</ul>
</li>
</ul>
<h4 id="3、什么是变量？"><a href="#3、什么是变量？" class="headerlink" title="3、什么是变量？"></a>3、什么是变量？</h4><ul>
<li>可变化的量，由变量名和变量值组成</li>
<li>每个变量都对应一块小内存，变量名用来查找对应的内存。变量值就是内存中保存的数据</li>
</ul>
<h4 id="4、内存，数据，变量三者关系？"><a href="#4、内存，数据，变量三者关系？" class="headerlink" title="4、内存，数据，变量三者关系？"></a>4、内存，数据，变量三者关系？</h4><ul>
<li>内存用来存储数据的空间</li>
<li>变量是内存的标识</li>
</ul>
<h4 id="5、赋值与内存的问题？"><a href="#5、赋值与内存的问题？" class="headerlink" title="5、赋值与内存的问题？"></a>5、赋值与内存的问题？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">问题： <span class="keyword">var</span> a = xxx, a内存中到底保存的是什么？</span><br><span class="line">答：</span><br><span class="line">若xxx是基本数据，保存的就是这个数据</span><br><span class="line">若xxx是对象，保存的就是对象的地址值</span><br><span class="line">若xxx是一个变量，保存的是xxx的内存内容（可能是基本数据，也可能是地址值）</span><br></pre></td></tr></table></figure>

<h4 id="6、关于引用变量赋值的问题？"><a href="#6、关于引用变量赋值的问题？" class="headerlink" title="6、关于引用变量赋值的问题？"></a>6、关于引用变量赋值的问题？</h4><ul>
<li>n 个引用变量指向同一个对象，通过一个变量修改对象内部数据，其他所有变量看到的是修改之后的数据</li>
<li>2 个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象</li>
<li>改对象，改变量</li>
</ul>
<h4 id="7、在-js-调用函数时传递变量参数时，是值传递还是引用传递？"><a href="#7、在-js-调用函数时传递变量参数时，是值传递还是引用传递？" class="headerlink" title="7、在 js 调用函数时传递变量参数时，是值传递还是引用传递？"></a>7、在 js 调用函数时传递变量参数时，是值传递还是引用传递？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 这里输出3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>理解 1: 都是值（基本&#x2F;地址值）传递</li>
<li>理解 2：可能是值传递，也可能是引用传递（地址值）</li>
</ul>
<h4 id="8、JS-引擎如何管理内存？"><a href="#8、JS-引擎如何管理内存？" class="headerlink" title="8、JS 引擎如何管理内存？"></a>8、JS 引擎如何管理内存？</h4><h5 id="1、内存生命周期"><a href="#1、内存生命周期" class="headerlink" title="1、内存生命周期"></a>1、内存生命周期</h5><ul>
<li>分配小内存空间，得到他的使用权</li>
<li>存储数据，可以反复操作</li>
<li>释放小内存空间</li>
</ul>
<h5 id="2、释放内存"><a href="#2、释放内存" class="headerlink" title="2、释放内存"></a>2、释放内存</h5><ul>
<li>局部变量：函数执行完自动释放</li>
<li>对象：成为垃圾对象&#x3D;&gt;垃圾回收器回收</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">//b是自动释放，b所指向的对象是在后面的某个时刻由垃圾回收期回收</span></span><br></pre></td></tr></table></figure>

<h2 id="03-对象"><a href="#03-对象" class="headerlink" title="03 对象"></a>03 对象</h2><h3 id="重点问题：-2"><a href="#重点问题：-2" class="headerlink" title="重点问题："></a>重点问题：</h3><h4 id="1、什么是对象？"><a href="#1、什么是对象？" class="headerlink" title="1、什么是对象？"></a>1、什么是对象？</h4><ul>
<li>多个数据的分装体</li>
<li>用来保存多个数据的容器</li>
<li>一个对象代表现实中的一个事物</li>
</ul>
<h4 id="2、为什么要使用对象？"><a href="#2、为什么要使用对象？" class="headerlink" title="2、为什么要使用对象？"></a>2、为什么要使用对象？</h4><ul>
<li>统一管理多个数据</li>
</ul>
<h4 id="3、对象的组成"><a href="#3、对象的组成" class="headerlink" title="3、对象的组成"></a>3、对象的组成</h4><ul>
<li>属性：属性名（字符串）和属性值</li>
<li>方法：一种特别的属性（属性值是函数）</li>
</ul>
<h4 id="4、如何访问对象内部数据"><a href="#4、如何访问对象内部数据" class="headerlink" title="4、如何访问对象内部数据"></a>4、如何访问对象内部数据</h4><ul>
<li>​ .属性名</li>
</ul>
<p>JS 访问对象属性有两种方法.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span> &#125;;</span><br><span class="line"><span class="title function_">alert</span>(p.<span class="property">name</span>); <span class="comment">//点号b</span></span><br><span class="line"><span class="title function_">alert</span>(p[name]); <span class="comment">//中括号</span></span><br></pre></td></tr></table></figure>

<p>第一是点符号法</p>
<p>点号要求后面的运算元是合法的标识符（即合法的变量命名）</p>
<p>第二是方括号表示法。括号之间的值可以是任何表达式只有这种是动态访问属性</p>
<p>因此，如果属性名称存储在变量中，则可以使用中括号表示法。</p>
<p>中括号要求的则是一个字符串即可，不必是合法的变量命名。如 4p 是不合法的变量命名（因为以数字开头），但却可以作为对象属性名(前提是字符串)</p>
<h5 id="什么时候必须使用-‘属性名’-的方式？"><a href="#什么时候必须使用-‘属性名’-的方式？" class="headerlink" title="什么时候必须使用[‘属性名’]的方式？"></a>什么时候必须使用[‘属性名’]的方式？</h5><ul>
<li><p>属性名包含特殊字符</p>
</li>
<li><p>变量名不确定</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量名不确定</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> propName = ‘pika’</span><br><span class="line"><span class="comment">//p.propName = value 不能使用</span></span><br><span class="line">P[propName] = value</span><br></pre></td></tr></table></figure>

<h2 id="04-函数"><a href="#04-函数" class="headerlink" title="04 函数"></a>04 函数</h2><h3 id="重点问题：-3"><a href="#重点问题：-3" class="headerlink" title="重点问题："></a>重点问题：</h3><h4 id="1、什么是函数？"><a href="#1、什么是函数？" class="headerlink" title="1、什么是函数？"></a>1、什么是函数？</h4><ul>
<li>实现特定功能的 n 条语句的封装体</li>
<li>只有函数时可以执行的，其他类型的数据不能执行</li>
</ul>
<h4 id="2、为什么要使用函数？"><a href="#2、为什么要使用函数？" class="headerlink" title="2、为什么要使用函数？"></a>2、为什么要使用函数？</h4><ul>
<li>提高代码复用</li>
<li>便于阅读交流</li>
</ul>
<h4 id="3、如何定义函数？"><a href="#3、如何定义函数？" class="headerlink" title="3、如何定义函数？"></a>3、如何定义函数？</h4><ul>
<li>函数声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//函数声明</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//表达式</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(“表达式”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、如何调用（执行）函数？"><a href="#4、如何调用（执行）函数？" class="headerlink" title="4、如何调用（执行）函数？"></a>4、如何调用（执行）函数？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意这里的test()是举例的一个函数</span><br><span class="line">//这里的obj是举例的一个对象</span><br><span class="line">* test() 直接调用</span><br><span class="line">* obj.test() 通过对象调用</span><br><span class="line">* new test() new调用</span><br><span class="line">* test.call/apply(obj) 临时让test成为obj的方法进行</span><br></pre></td></tr></table></figure>

<h2 id="05-回调函数"><a href="#05-回调函数" class="headerlink" title="05 回调函数"></a>05 回调函数</h2><h3 id="重点问题：-4"><a href="#重点问题：-4" class="headerlink" title="重点问题："></a>重点问题：</h3><h4 id="1、什么函数才是回调函数？（需满足-3-个条件）"><a href="#1、什么函数才是回调函数？（需满足-3-个条件）" class="headerlink" title="1、什么函数才是回调函数？（需满足 3 个条件）"></a>1、什么函数才是回调函数？（需满足 3 个条件）</h4><ul>
<li>你定义的</li>
<li>你没有调用</li>
<li>最终它执行了</li>
</ul>
<h4 id="2、常见的回调函数？"><a href="#2、常见的回调函数？" class="headerlink" title="2、常见的回调函数？"></a>2、常见的回调函数？</h4><ul>
<li>dom 事件回调函数</li>
<li>定时器回调函数</li>
<li>ajax 请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<h2 id="06-IIFE"><a href="#06-IIFE" class="headerlink" title="06 IIFE"></a>06 IIFE</h2><h3 id="1、理解"><a href="#1、理解" class="headerlink" title="1、理解"></a>1、理解</h3><p>全称：Immediately-Invoked Function Expression</p>
<p>立即调用函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//匿名函数自调用</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="number">3</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里定义的a和上面的a相互之间不影响，因为在不同的作用域里面</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">cosole.<span class="title function_">log</span>(a);</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(++a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">$</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//向外暴露一个全局函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//相当于[test:test]</span></span><br><span class="line">      <span class="comment">//左边test是属性名，右边test是属性值</span></span><br><span class="line">      <span class="attr">test</span>: test,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里我们想得到++a的输出</span></span><br><span class="line"><span class="comment">//$是一个函数。$执行后返回的是一个对象</span></span><br><span class="line">$().<span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><ul>
<li>隐藏实现</li>
<li>不会污染外部命名空间（一般指全局命名空间）</li>
<li>用它来编写 js 模块</li>
</ul>
<h2 id="07-函数的中的-this"><a href="#07-函数的中的-this" class="headerlink" title="07 函数的中的 this"></a>07 函数的中的 this</h2><h3 id="1、this-是什么"><a href="#1、this-是什么" class="headerlink" title="1、this 是什么?"></a>1、this 是什么?</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getColor</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setColor</span> = <span class="keyword">function</span> (<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;red&quot;</span>); <span class="comment">//this是谁？ window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yellow&quot;</span>); <span class="comment">//this是谁？ p</span></span><br><span class="line"></span><br><span class="line">p.<span class="title function_">getColor</span>(); <span class="comment">//this是谁？ p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">p.<span class="property">setColor</span>.<span class="title function_">call</span>(obj, <span class="string">&quot;black&quot;</span>); <span class="comment">//this是谁？ obj（call强制改变this的指向）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = p.<span class="property">setColor</span>;</span><br><span class="line"><span class="title function_">test</span>(); <span class="comment">//this是谁？ window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fun2</span>(); <span class="comment">//this是谁 window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>任何函数本质上都是通过某一个对象来调用的，如果没有指定就是 window</li>
<li>所有函数内部都有一个变量 this</li>
<li>他的值是调用函数的当前对象</li>
</ul>
<h3 id="2、如何确定-this-的值？"><a href="#2、如何确定-this-的值？" class="headerlink" title="2、如何确定 this 的值？"></a>2、如何确定 this 的值？</h3><ul>
<li>test() window</li>
<li>p.test() p</li>
<li>new test() 新创建的对象</li>
<li>p.call(obj) obj</li>
</ul>
<h2 id="08-JS-分号中的问题"><a href="#08-JS-分号中的问题" class="headerlink" title="08 JS 分号中的问题"></a>08 JS 分号中的问题</h2><p>1、js 一条语句的后面可以不加分号</p>
<p>2、是否加分号是编码风格问题，没有应该不应该，只有你自己喜欢不喜欢</p>
<p>3、在下面 2 种情况下不加分号会有问题</p>
<ul>
<li>小括号开头的前一条语句</li>
<li>中方括号开头的前一条语句</li>
</ul>
<p>4、解决方法：在行首加分号</p>
<p>5、强有力的例子：vue.js 库</p>
<h1 id="二、JS-函数高级"><a href="#二、JS-函数高级" class="headerlink" title="二、JS 函数高级"></a>二、JS 函数高级</h1><h2 id="01-原型和原型链"><a href="#01-原型和原型链" class="headerlink" title="01 原型和原型链"></a>01 原型和原型链</h2><h3 id="1、函数的-prototype-属性"><a href="#1、函数的-prototype-属性" class="headerlink" title="1、函数的 prototype 属性"></a>1、函数的 prototype 属性</h3><ul>
<li>每个函数对象都有一个 prototype 属性，它默认指向一个 Object 空对象（即称为：原型对象）</li>
<li>new obj（）new 出来的一个对象是没有 prototype 属性的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">fn2.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//默认指向一个Object空对象（没有我们的属性）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn2.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//指向一个object对象（有我们的属性test）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原型对象中有个属性 constructor，它指向函数对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型对象中有个属性constructor，它指向函数对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>  <span class="title class_">Date</span>)<span class="comment">//输出true</span></span><br></pre></td></tr></table></figure>

<h3 id="2、给原型对象"><a href="#2、给原型对象" class="headerlink" title="2、给原型对象"></a>2、给原型对象</h3><ul>
<li>作用：函数的所有实例对象自动拥有原型中的属性（方法）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给原型对象添加属性（一般是方法） =&gt; 实例对象可以访问</span></span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个实例</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">fun, <span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<h2 id="02-显示原型和隐式原型"><a href="#02-显示原型和隐式原型" class="headerlink" title="02 显示原型和隐式原型"></a>02 显示原型和隐式原型</h2><h3 id="1、每个函数-function-都有一个-prototype-即显式原型（属性）"><a href="#1、每个函数-function-都有一个-prototype-即显式原型（属性）" class="headerlink" title="1、每个函数 function 都有一个 prototype, 即显式原型（属性）"></a>1、每个函数 function 都有一个 prototype, 即显式原型（属性）</h3><h3 id="2、每个实例对象都有个-proto-可称为隐式原型（属性）"><a href="#2、每个实例对象都有个-proto-可称为隐式原型（属性）" class="headerlink" title="2、每个实例对象都有个__proto__,可称为隐式原型（属性）"></a>2、每个实例对象都有个__proto__,可称为隐式原型（属性）</h3><h3 id="3、对象的隐式原型的值为其对应构造函数的显式原型的值"><a href="#3、对象的隐式原型的值为其对应构造函数的显式原型的值" class="headerlink" title="3、对象的隐式原型的值为其对应构造函数的显式原型的值"></a>3、对象的隐式原型的值为其对应构造函数的显式原型的值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、每个函数function都要一个prototype，即显式原型属性，默认指向一个空的Object对象</span></span><br><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125; <span class="comment">//内部语句：this.prototype =&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、每个实例对象都有一个__proto__，可称为隐式原型</span></span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>(); <span class="comment">//内部语句：this.__proto__ = Fn.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、对象的隐式原型的值为其对应构造函数的显式原型的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = fn.<span class="property">__proto__</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型添加方法</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过实例调用原型的方法</span></span><br><span class="line">fn.<span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<h3 id="4、内部结构图"><a href="#4、内部结构图" class="headerlink" title="4、内部结构图"></a>4、内部结构图</h3><p><img src="https://www.hualigs.cn/image/643e59686e545.jpg" alt="image-20190703132218240"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul>
<li>函数的 prototype 属性：在定义函数时自动添加的，默认值是一个空 Object 对象</li>
<li>对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的 prototype 属性值</li>
<li>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6 之前）</li>
</ul>
<h2 id="03-原型链"><a href="#03-原型链" class="headerlink" title="03 原型链"></a>03 原型链</h2><h3 id="1、原型链（隐式原型链）（图解）"><a href="#1、原型链（隐式原型链）（图解）" class="headerlink" title="1、原型链（隐式原型链）（图解）"></a>1、原型链（隐式原型链）（图解）</h3><ul>
<li>访问一个对象的属性时，<ul>
<li>先在自身属性中查找，找到返回</li>
<li>如果没有，再沿着__proto__这条链向上查找，找到返回</li>
<li>如果最终没有找到，返回 undefined</li>
</ul>
</li>
</ul>
<p><img src="https://www.hualigs.cn/image/643e5b428eb94.jpg" alt="image-20190703134312917"></p>
<ul>
<li>原型链本质上是隐式原型链</li>
<li>作用：查找对象的属性（方法）</li>
</ul>
<h3 id="2、构造函数-原型-实体对象的关系（图解）"><a href="#2、构造函数-原型-实体对象的关系（图解）" class="headerlink" title="2、构造函数&#x2F;原型&#x2F;实体对象的关系（图解）"></a>2、构造函数&#x2F;原型&#x2F;实体对象的关系（图解）</h3><p><img src="https://www.hualigs.cn/image/643e5bb870ce1.jpg" alt="image-20190703135044729"></p>
<h3 id="3、构造函数-原型-实体对象的关系-2（图解）"><a href="#3、构造函数-原型-实体对象的关系-2（图解）" class="headerlink" title="3、构造函数&#x2F;原型&#x2F;实体对象的关系 2（图解）"></a>3、构造函数&#x2F;原型&#x2F;实体对象的关系 2（图解）</h3><ul>
<li>所有函数都有显式原型和隐式原型</li>
<li><img src="https://www.hualigs.cn/image/643e5bb870ce1.jpg" alt="image-20190703142201421"></li>
</ul>
<p>问题：为什么 Object 是实例只能用 Object.prototype 中都方法，无法用 Object 都私有方法？<br>答：因为我们只能顺着原型链<strong>proto</strong>查找原型 prototype 上的方法，无法访问到其私有的方法。私有的方法和属性只有自己能调用。利用 hasOwnProperty()方法可以区分是自己私有的，还是原型上的方法和属性。<br>prototype 是自己私有的属性，但是 prototype 指向的堆中的方法和属性不是自己私有的。</p>
<h3 id="4、函数的显式原型指向的对象默认是空-Object-实例对象（除-Object-不满足）"><a href="#4、函数的显式原型指向的对象默认是空-Object-实例对象（除-Object-不满足）" class="headerlink" title="4、函数的显式原型指向的对象默认是空 Object 实例对象（除 Object 不满足）"></a>4、函数的显式原型指向的对象默认是空 Object 实例对象（除 Object 不满足）</h3><h3 id="即-xxx-prototype-instanceof-Object"><a href="#即-xxx-prototype-instanceof-Object" class="headerlink" title="即: xxx.prototype instanceof Object"></a>即: xxx.prototype instanceof Object</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//false,只有这个是例外</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="5、所有函数都是-Function-的实例（包括-Function）"><a href="#5、所有函数都是-Function-的实例（包括-Function）" class="headerlink" title="5、所有函数都是 Function 的实例（包括 Function）"></a>5、所有函数都是 Function 的实例（包括 Function）</h3><h3 id="即：xxx-proto-Function-prototype"><a href="#即：xxx-proto-Function-prototype" class="headerlink" title="即：xxx.__proto__ &#x3D; Function.prototype"></a>即：xxx.__proto__ &#x3D; Function.prototype</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="title class_">Function</span>.<span class="property">__proto__</span> = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="6、Object-的原型对象是原型链尽头"><a href="#6、Object-的原型对象是原型链尽头" class="headerlink" title="6、Object 的原型对象是原型链尽头"></a>6、Object 的原型对象是原型链尽头</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<h2 id="04-原型链属性问题"><a href="#04-原型链属性问题" class="headerlink" title="04 原型链属性问题"></a>04 原型链属性问题</h2><ul>
<li>读取对象的属性值时候，会自动到原型链（隐式原型链）中查找</li>
<li>设置对象属性值时候：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = ’xxx‘</span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property">a</span>) <span class="comment">//xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">fn2.<span class="property">a</span> = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property">a</span>, fn2.<span class="property">a</span>)<span class="comment">//xxx yyy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="comment">//方法一般定义在原型里</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="05-instanceof-探索"><a href="#05-instanceof-探索" class="headerlink" title="05 instanceof 探索"></a>05 instanceof 探索</h2><h3 id="1、instanceof-是如何判断的"><a href="#1、instanceof-是如何判断的" class="headerlink" title="1、instanceof 是如何判断的"></a>1、instanceof 是如何判断的</h3><ul>
<li>表达式 Ainstanceof B</li>
<li>如果 B 函数的显式原型对象在 A 对象的原型链上，返回 true, 否则返回 false0</li>
</ul>
<h2 id="06-面试题（原型与原型链）"><a href="#06-面试题（原型与原型链）" class="headerlink" title="06 面试题（原型与原型链）"></a>06 面试题（原型与原型链）</h2><h3 id="1、测试题-1"><a href="#1、测试题-1" class="headerlink" title="1、测试题 1"></a>1、测试题 1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>, b.<span class="property">m</span>, c.<span class="property">n</span>, c.<span class="property">m</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/643e5c153c548.jpg" alt="image-20190703163024695"></p>
<h3 id="2、测试题-2"><a href="#2、测试题-2" class="headerlink" title="2、测试题 2"></a>2、测试题 2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">a</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">b</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="title function_">a</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="title function_">b</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//var F =function()&#123;&#125; 和 var f = new F()不同！！</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.hualigs.cn/image/643e5c3cce56c.jpg" alt="image-20190703171236209"></p>
<h2 id="07-变量提升与函数提升"><a href="#07-变量提升与函数提升" class="headerlink" title="07 变量提升与函数提升"></a>07 变量提升与函数提升</h2><p>变量作为 window 对象属性放入上下文栈中，这叫变量优先预处理，而函数的上下文后放入栈中，变量随后放入栈中，但是执行的时候是先执行栈顶的函数。</p>
<p>函数提升优先级高是指先执行，所以对于栈的执行顺序来说，需要在变量提升之后提升</p>
<h3 id="1、变量声明提升"><a href="#1、变量声明提升" class="headerlink" title="1、变量声明提升"></a>1、变量声明提升</h3><ul>
<li>通过 var 定义(声明)的变量，在定义语句之前就可以访问到</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面试题：输出a的值为多少</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码实际执行是下面这段</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//undefined 变量提升</span></span><br><span class="line"><span class="title function_">fn2</span>(); <span class="comment">//可调用 函数提升</span></span><br><span class="line"><span class="title function_">fn3</span>(); <span class="comment">//不能 变量提升</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn3()&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、函数声明提升"><a href="#2、函数声明提升" class="headerlink" title="2、函数声明提升"></a>2、函数声明提升</h3><ul>
<li>通过 function 声明的函数，在之前就可以直接调用</li>
</ul>
<h2 id="08-执行上下文"><a href="#08-执行上下文" class="headerlink" title="08 执行上下文"></a>08 执行上下文</h2><h3 id="1、代码分类（位置）"><a href="#1、代码分类（位置）" class="headerlink" title="1、代码分类（位置）"></a>1、代码分类（位置）</h3><ul>
<li>全局代码</li>
<li>函数（局部）代码</li>
</ul>
<h3 id="2、全局执行上下文-在执行全局代码前做的准备工作"><a href="#2、全局执行上下文-在执行全局代码前做的准备工作" class="headerlink" title="2、全局执行上下文(在执行全局代码前做的准备工作)"></a>2、全局执行上下文(在执行全局代码前做的准备工作)</h3><ul>
<li>在执行全局代码前将 window 确定为全局执行上下文</li>
<li>对全局数据进行预处理</li>
<li>var 定义传递全局变量 &gt; undefined, 添加为 window 的方法</li>
<li>function 声明的全局函数 &gt; 赋值（fun）,添加为 window 的方法</li>
<li>this &#x3D;&gt; 赋值（window）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局执行上下文</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1, <span class="variable language_">window</span>.<span class="property">a1</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">a2</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a2()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数执行上下文</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">//2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">//undefined</span></span><br><span class="line">  <span class="title function_">a3</span>(); <span class="comment">//a3()</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">  cosole.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">//这里的arguments是封装实参的类数组对象,这里输出（2,3）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a2 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a3()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3、函数执行上下文"><a href="#3、函数执行上下文" class="headerlink" title="3、函数执行上下文"></a>3、函数执行上下文</h3><ul>
<li>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）</li>
<li>对局部数据进行预处理<ul>
<li>形参变量 &gt; 赋值（实参）&gt; 添加为执行上下文的属性</li>
<li>arguments &gt; 赋值（实参列表），添加为执行上下文的属性</li>
<li>var 定义的局部变量 &gt; undefined, 添加为执行上下文的属性</li>
<li>function 声明的函数 &gt; 赋值（fun）,添加为执行上下文的方法</li>
<li>this &gt; 赋值（调用函数的对象）</li>
</ul>
</li>
<li>开始执行函数体代码</li>
</ul>
<h3 id="4、执行上下文对象个数：n-1-原则"><a href="#4、执行上下文对象个数：n-1-原则" class="headerlink" title="4、执行上下文对象个数：n+1 原则"></a>4、执行上下文对象个数：n+1 原则</h3><p>n 是函数调用次数，1 是一个全局执行上下文对象</p>
<h2 id="09-执行上下文栈-后进先出-LIFO"><a href="#09-执行上下文栈-后进先出-LIFO" class="headerlink" title="09 执行上下文栈(后进先出 LIFO)"></a>09 执行上下文栈(后进先出 LIFO)</h2><ul>
<li>在全局代码执行之前，JS 引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li>
<li>在函数执行上下文创建之后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完毕后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完之后，栈中只剩下 window</li>
</ul>
<p><img src="https://www.hualigs.cn/image/643e5c7e7c36d.jpg" alt="image-20190704121521915"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;global begin:&#x27;</span> + i)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">i</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i  <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo() begin:&#x27;</span> + i)</span><br><span class="line">    <span class="title function_">foo</span>(i + <span class="number">1</span>) <span class="comment">//递归调用：在函数内部调用自己</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo() end: &#x27;</span> + i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;global end:&#x27;</span> + i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码依次输出什么？</span></span><br><span class="line"><span class="comment">//整个过程中产生了几个执行上下文？ 5</span></span><br></pre></td></tr></table></figure>

<h2 id="10-面试题（执行上下文与执行上下文栈）"><a href="#10-面试题（执行上下文与执行上下文栈）" class="headerlink" title="10 面试题（执行上下文与执行上下文栈）"></a>10 面试题（执行上下文与执行上下文栈）</h2><h3 id="1、面试题-1"><a href="#1、面试题-1" class="headerlink" title="1、面试题 1"></a>1、面试题 1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面试题1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数提升优先级比变量提升优先级要高，且不会被变量声明覆盖，但是会被变量赋值覆盖</span></span><br></pre></td></tr></table></figure>

<p>红皮书 111 页说道：<strong>解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升</strong>、JavaScript 上卷中第 40 页提到<strong>函数声明是优于变量提升的</strong>。</p>
<p>函数提升是声明并赋值的，而变量提升只是声明，但是函数赋值诗可以被变量赋值覆盖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getName);</span><br><span class="line"><span class="keyword">var</span> getName = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="comment">//f getName()&#123;console.log(2)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getName); <span class="comment">//f getName()&#123;console.log(2)&#125;</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getName); <span class="comment">//f()&#123;cosole.log(3)&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getName); <span class="comment">//f()&#123;cosole.log(3)&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、面试题-2"><a href="#2、面试题-2" class="headerlink" title="2、面试题 2"></a>2、面试题 2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面试题2</span></span><br><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="variable language_">window</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="3、面试题"><a href="#3、面试题" class="headerlink" title="3、面试题"></a>3、面试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>(<span class="number">2</span>); <span class="comment">//c is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="11-作用域"><a href="#11-作用域" class="headerlink" title="11 作用域"></a>11 作用域</h2><h3 id="1、理解-1"><a href="#1、理解-1" class="headerlink" title="1、理解"></a>1、理解</h3><ul>
<li><p>一块“地盘”，一个代码段所在的区域</p>
</li>
<li><p>它是静态的，相对于上下文对象，在编写代码时候就确定了</p>
</li>
</ul>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><ul>
<li><p>全局作用域</p>
</li>
<li><p>函数作用域</p>
</li>
<li><p>块作用域（ES6 有了，let 声明的范围是块作用域）</p>
<p>【块作用域就是大括号之间的范围】</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有块作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有块作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//b is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="3、作用域个数：n-1-m"><a href="#3、作用域个数：n-1-m" class="headerlink" title="3、作用域个数：n+1+m"></a>3、作用域个数：n+1+m</h3><p>n 是函数定义次数，1 是一个全局作用域，m 是块作用域个数</p>
<p><img src="https://www.hualigs.cn/image/643e5cc48484c.jpg" alt="image-20190704133932122"></p>
<h3 id="4、作用"><a href="#4、作用" class="headerlink" title="4、作用"></a>4、作用</h3><ul>
<li>隔离变量，不同作用域下同名变量下不会有冲突</li>
</ul>
<h2 id="12-作用域与执行上下文"><a href="#12-作用域与执行上下文" class="headerlink" title="12 作用域与执行上下文"></a>12 作用域与执行上下文</h2><h3 id="1、区别-1"><a href="#1、区别-1" class="headerlink" title="1、区别 1"></a>1、区别 1</h3><ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后，js 代码马上执行之前创建</li>
<li>函数执行上下文是在调用函数时，函数体代码执行之前创建</li>
</ul>
<h3 id="2、区别-2"><a href="#2、区别-2" class="headerlink" title="2、区别 2"></a>2、区别 2</h3><ul>
<li>作用域是静态的，只要函数定义好了就一直存在，且不会再变化</li>
<li>上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会自动释放</li>
</ul>
<h3 id="3、联系"><a href="#3、联系" class="headerlink" title="3、联系"></a>3、联系</h3><ul>
<li>上下文环境（对象）是从属于所在的作用域</li>
<li>全局上下文环境 &#x3D;&gt; 全局作用域</li>
<li>函数上下文环境 &#x3D;&gt; 对应的函数使用域</li>
</ul>
<p><img src="https://www.hualigs.cn/image/643e5ce3bdae6.jpg" alt="image-20190704143640637"></p>
<h2 id="13-作用域链"><a href="#13-作用域链" class="headerlink" title="13 作用域链"></a>13 作用域链</h2><h3 id="1、理解-2"><a href="#1、理解-2" class="headerlink" title="1、理解"></a>1、理解</h3><ul>
<li>多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外）</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
<h3 id="2、查找一个变量的查找规则"><a href="#2、查找一个变量的查找规则" class="headerlink" title="2、查找一个变量的查找规则"></a>2、查找一个变量的查找规则</h3><ul>
<li>在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入上一级</li>
<li>重复执行操作，直到全局作用域，如果还找不到就抛出找不到的异常</li>
</ul>
<p><img src="https://www.hualigs.cn/image/643e5d053e6fc.jpg" alt="image-20190704143734563"></p>
<h2 id="14-面试题（作用域与作用链）"><a href="#14-面试题（作用域与作用链）" class="headerlink" title="14 面试题（作用域与作用链）"></a>14 面试题（作用域与作用链）</h2><h3 id="1、面试题-1-1"><a href="#1、面试题-1-1" class="headerlink" title="1、面试题 1"></a>1、面试题 1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fn);</span><br><span class="line"><span class="comment">//因为作用域静态，定义就确定了，所有fn()向上一级找x的值是直接找到全局x 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************上下对比*************/</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  <span class="title function_">f</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fn); <span class="comment">//20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="2、面试题-2-1"><a href="#2、面试题-2-1" class="headerlink" title="2、面试题 2"></a>2、面试题 2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">//function()&#123;console.log(fn)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fn2);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn2</span>(); <span class="comment">//报错，fn2 Is没有用this，默认是window.fn2()，此外，这里的fn2不是变量，是属性，如果想找到需要obj.fn2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********上下对比*****************/</span></span><br><span class="line"><span class="comment">//如果想让上面的obj.fn2()找到，需要改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-闭包"><a href="#15-闭包" class="headerlink" title="15 闭包"></a>15 闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, length = btns.<span class="property">length</span>; i &lt; length; i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> btn = btns[i]</span><br><span class="line">	<span class="comment">//将btn所对应的下标保存在btn上</span></span><br><span class="line">	btn.<span class="property">index</span> = i</span><br><span class="line">	btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;第&#x27;</span> + (<span class="variable language_">this</span>.<span class="property">index</span> + <span class="number">1</span> + ‘个’))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********上下对比****************/</span></span><br><span class="line"><span class="comment">//利用闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, length = btns.<span class="property">length</span>; i &lt; length; i++)&#123;</span><br><span class="line">	(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> btn = btns[i]</span><br><span class="line">		<span class="comment">//将btn所对应的下标保存在btn上</span></span><br><span class="line">		btn.<span class="property">index</span> = i</span><br><span class="line">		btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&#x27;第&#x27;</span> + (<span class="variable language_">this</span>.<span class="property">index</span> + <span class="number">1</span> + ‘个’))</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、如何产生闭包？"><a href="#1、如何产生闭包？" class="headerlink" title="1、如何产生闭包？"></a>1、如何产生闭包？</h3><ul>
<li>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包</li>
</ul>
<h3 id="2、闭包到底是什么？"><a href="#2、闭包到底是什么？" class="headerlink" title="2、闭包到底是什么？"></a>2、闭包到底是什么？</h3><p>闭包不是任何代码，闭包是函数运行的机制</p>
<p>函数执行的过程中，会形成一个全新的私有上下文</p>
<p>1、保护：保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）</p>
<p>2、保存：如果当前上下文不被释放[只要让上下文中的某个东西被外部占用即可]，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了</p>
<p>我们把函数执行所带来的两大作用（两大机制），称之为闭包</p>
<ul>
<li>使用 Chrome 调试查看</li>
<li>理解一：闭包是嵌套的内部函数（绝大部分人）</li>
<li>理解二：包含被引用变量（函数）的对象（极少数人）</li>
<li>注意：闭包存在于嵌套的内部函数中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//执行函数定义就会产生闭包（不用调用内部函数）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********上下对比**********/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> fn2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//这个不是闭包，因为fn2是变量提升，而非函数提升，所以这里的fn2是undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<h3 id="3、产生闭包的条件？"><a href="#3、产生闭包的条件？" class="headerlink" title="3、产生闭包的条件？"></a>3、产生闭包的条件？</h3><ul>
<li><p>函数嵌套</p>
</li>
<li><p>内部函数引用了外部函数的数据（变量&#x2F;函数）</p>
</li>
<li><p>闭包产生不一定要内部函数执行，但闭包产生一定是执行了外部函数</p>
</li>
</ul>
<h2 id="16-常见的闭包"><a href="#16-常见的闭包" class="headerlink" title="16 常见的闭包"></a>16 常见的闭包</h2><h3 id="1、将函数作为另一个函数的返回值"><a href="#1、将函数作为另一个函数的返回值" class="headerlink" title="1、将函数作为另一个函数的返回值"></a>1、将函数作为另一个函数的返回值</h3><h3 id="2、将函数作为实参传递给另一个函数调用"><a href="#2、将函数作为实参传递给另一个函数调用" class="headerlink" title="2、将函数作为实参传递给另一个函数调用"></a>2、将函数作为实参传递给另一个函数调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;、b = &quot;</span> + b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//a = 3、b = 4</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//a = 4、b = 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn2.<span class="property">b</span>); <span class="comment">//报错fn2 is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********上下对比*****************/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a--;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//1</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包里面只有a,没有fn2和fn3</span></span><br><span class="line"><span class="comment">//局部变量fn3被释放了，但是fn3所保存的函数对象的地址值返回给了全局变量f了</span></span><br><span class="line"><span class="comment">//闭包一直存在没有消失的原因是第31行f导致的</span></span><br></pre></td></tr></table></figure>

<h3 id="3、问题："><a href="#3、问题：" class="headerlink" title="3、问题："></a>3、问题：</h3><h4 id="1、函数执行完之后，函数内部声明的局部变量是否还存在？"><a href="#1、函数执行完之后，函数内部声明的局部变量是否还存在？" class="headerlink" title="1、函数执行完之后，函数内部声明的局部变量是否还存在？"></a>1、函数执行完之后，函数内部声明的局部变量是否还存在？</h4><p>一般不存在，存在于闭包之中的变量才可能存在</p>
<p>所以这里对于上面的例子，是存在的</p>
<p>原因是 fn1 存在于闭包之中，所以 fn1 内部声明的局部变量 a 还存在</p>
<p>闭包保存了函数需要的局部变量的值，便于函数调用时获取这些值</p>
<h4 id="2、在函数外部能直接访问函数内部的局部变量嘛？"><a href="#2、在函数外部能直接访问函数内部的局部变量嘛？" class="headerlink" title="2、在函数外部能直接访问函数内部的局部变量嘛？"></a>2、在函数外部能直接访问函数内部的局部变量嘛？</h4><p>不能，但我们可以通过闭包让外部操作它</p>
<p><img src="https://www.hualigs.cn/image/643e5d7f1a0c2.jpg" alt="image-20190708175431868"></p>
<p><img src="https://www.hualigs.cn/image/643e5d7f5d6ed.jpg" alt="image-20190708175421288"></p>
<h3 id="4、闭包的作用："><a href="#4、闭包的作用：" class="headerlink" title="4、闭包的作用："></a>4、闭包的作用：</h3><ul>
<li>使用函数内部的变量在函数执行完之后，仍然存活在内存中（延长了局部变量的生命周期）</li>
<li>让函数外部可以操作（读写到函数内部的数据（变量&#x2F;函数））</li>
</ul>
<h3 id="5、闭包的生命周期"><a href="#5、闭包的生命周期" class="headerlink" title="5、闭包的生命周期"></a>5、闭包的生命周期</h3><ul>
<li>产生：在嵌套内部函数定义执行完时就产生了（不是在调用）</li>
<li>死亡：在嵌套的内部函数成为垃圾对象时</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>();</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//3</span></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">//4，这个时候闭包还存活着</span></span><br><span class="line">f = <span class="literal">null</span>; <span class="comment">//闭包死亡，（包含闭包的函数对象成为了垃圾对象）</span></span><br></pre></td></tr></table></figure>

<h3 id="6、闭包的应用-自定义-JS-模块"><a href="#6、闭包的应用-自定义-JS-模块" class="headerlink" title="6、闭包的应用_自定义 JS 模块"></a>6、闭包的应用_自定义 JS 模块</h3><ul>
<li><p>具有特定功能的 JS 模块</p>
</li>
<li><p>将所有的数据和功能都封装在一个函数内部（私有的）</p>
</li>
<li><p>只向外暴露一个包含 n 个方法的对象或方法</p>
</li>
<li><p>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</p>
</li>
</ul>
<h3 id="7、闭包的缺点"><a href="#7、闭包的缺点" class="headerlink" title="7、闭包的缺点"></a>7、闭包的缺点</h3><p>1、缺点</p>
<ul>
<li>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长</li>
<li>容易造成内存泄漏</li>
</ul>
<p>2、解决</p>
<ul>
<li>能不用闭包就不用</li>
<li>及时释放</li>
</ul>
<h4 id="内存溢出（程序已经出错了-质变）"><a href="#内存溢出（程序已经出错了-质变）" class="headerlink" title="内存溢出（程序已经出错了, 质变）"></a>内存溢出（程序已经出错了, 质变）</h4><ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误</li>
</ul>
<h4 id="内存泄漏（程序还能正常运行，还没有出错，量变）"><a href="#内存泄漏（程序还能正常运行，还没有出错，量变）" class="headerlink" title="内存泄漏（程序还能正常运行，还没有出错，量变）"></a>内存泄漏（程序还能正常运行，还没有出错，量变）</h4><ul>
<li>占用的内存没有及时释放</li>
<li>内存泄漏积累多了就容易导致内存溢出</li>
<li>常见的内存泄漏：<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
<h3 id="8、面试题"><a href="#8、面试题" class="headerlink" title="8、面试题"></a>8、面试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面试题1</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;the window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;MyObject&quot;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">getNameFunc</span>()()); <span class="comment">// the window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********上下对比*************/</span></span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">&quot;the window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">  <span class="attr">name2</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  <span class="attr">getNameFunc</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> that.<span class="property">name2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(object2.<span class="title function_">getNameFunc</span>()()); <span class="comment">//My Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题2 终极！！！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">n, o</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">fun</span>: <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fun</span>(m, n);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">fun</span>(<span class="number">0</span>);</span><br><span class="line">a.<span class="title function_">fun</span>(<span class="number">1</span>);</span><br><span class="line">a.<span class="title function_">fun</span>(<span class="number">2</span>);</span><br><span class="line">a.<span class="title function_">fun</span>(<span class="number">3</span>); <span class="comment">//undefined, 0 ,0 ,0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">fun</span>(<span class="number">0</span>).<span class="title function_">fun</span>(<span class="number">1</span>).<span class="title function_">fun</span>(<span class="number">2</span>).<span class="title function_">fun</span>(<span class="number">3</span>); <span class="comment">//undefined, 0, 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="title function_">fun</span>(<span class="number">0</span>).<span class="title function_">fun</span>(<span class="number">1</span>);</span><br><span class="line">c.<span class="title function_">fun</span>(<span class="number">2</span>);</span><br><span class="line">c.<span class="title function_">fun</span>(<span class="number">3</span>); <span class="comment">//underfined, 0, 1, 1</span></span><br></pre></td></tr></table></figure>

<h2 id="17-纯函数"><a href="#17-纯函数" class="headerlink" title="17 纯函数"></a>17 纯函数</h2><p>一类特别的函数，只要是同样的输入（实参），必定会得到同样的输出（返回）</p>
<p>必须遵守以下一些约束</p>
<p>​ 1、不得改写参数数据</p>
<p>​ 2、不会产生任何副作用，例如网络请求、输入和输出设备</p>
<p>​ 3、不能调用 Date.now()或 Math.random()等不纯的方法</p>
<p>​ redux 的 render 函数必须是一个纯函数</p>
<h3 id="纯函数好处"><a href="#纯函数好处" class="headerlink" title="纯函数好处"></a>纯函数好处</h3><blockquote>
<p>1、可缓存</p>
<p>自己模拟一个 memoize 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记忆函数（封装实现）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取圆的面积</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">r</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getArea调用啦！&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memorized</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="comment">// 缓存的地方</span></span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 由于arguments是类数组结构，这里给转化为数组</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    cache[key] = cache[key] || f.<span class="title function_">apply</span>(f, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里调用记忆函数传入相同的参数会不再调用函数，而是直接返回缓存的数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getAreaMemory = <span class="title function_">memorized</span>(getArea);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(1)&quot;</span>, <span class="title function_">getAreaMemory</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(2)&quot;</span>, <span class="title function_">getAreaMemory</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(3)&quot;</span>, <span class="title function_">getAreaMemory</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>2、可测试</p>
<p>3、并行处理</p>
<p>纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数</p>
</blockquote>
<h3 id="18-柯里化（Currying）"><a href="#18-柯里化（Currying）" class="headerlink" title="18 柯里化（Currying）"></a>18 柯里化（Currying）</h3><blockquote>
<p>当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）</p>
<p>然后返回一个新的函数接收剩余的参数，返回结果</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的柯里化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span>(<span class="params">min</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age &gt;= min;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">checkAge</span> = (<span class="params">min</span>) =&gt; <span class="function">(<span class="params">age</span>) =&gt;</span> age &gt;= min;</span><br><span class="line"><span class="keyword">let</span> checkAge18 = <span class="title function_">checkAge</span>(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">checkAge18</span>(<span class="number">18</span>));</span><br></pre></td></tr></table></figure>

<h4 id="lodash-中的纯函数"><a href="#lodash-中的纯函数" class="headerlink" title="lodash 中的纯函数"></a>lodash 中的纯函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//lodash中的curry基本使用</span><br><span class="line">const _ = require(&quot;lodash&quot;)</span><br><span class="line"></span><br><span class="line">function getSum(a, b, c)&#123;</span><br><span class="line">	return a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const curried = _.curry(getSum)</span><br><span class="line"></span><br><span class="line">console.log(curried(1,2,3))</span><br><span class="line">console.log(curried(1)(2,3))</span><br><span class="line">console.log(curried(1,2)(3))</span><br></pre></td></tr></table></figure>

<h4 id="柯里化函数封装"><a href="#柯里化函数封装" class="headerlink" title="柯里化函数封装"></a>柯里化函数封装</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 柯里化原理（封装）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curriedFn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 分情况判断,</span></span><br><span class="line">    <span class="comment">// 1、如果传入的形参个数少于函数所需的参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; func.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//这里有已经产生了闭包，arg是缓存的变量</span></span><br><span class="line">        <span class="comment">// 将arguments中的参数值同后续的参数合并</span></span><br><span class="line">        <span class="comment">// concat是合并数组</span></span><br><span class="line">        <span class="comment">// Array.from()可以将一个类数组对象或者可遍历对象转换成一个真正的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curriedFn</span>(...args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、当实际传入的形参个数大于等于所需参数个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="柯里化总结："><a href="#柯里化总结：" class="headerlink" title="柯里化总结："></a>柯里化总结：</h3><ul>
<li>柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新参数</li>
<li>这是一种对函数参数的‘缓存’</li>
<li>让函数变的更灵活，让函数的粒度更小</li>
<li>可以把多元函数转换为一元函数，可以组合使用函数产生强大的功能</li>
</ul>
</blockquote>
<h2 id="18-函数组合"><a href="#18-函数组合" class="headerlink" title="18 函数组合"></a>18 函数组合</h2><blockquote>
<p>纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))</p>
<ul>
<li>获取数组的最后一个元素再转换成大写字母 _.toUpper(_.first(_.reverse(array)))</li>
<li>函数组合可以让我们把细粒度的函数重新组合生成一个新的函数</li>
</ul>
</blockquote>
<p><img src="https://www.hualigs.cn/image/643e5da38fa8d.jpg" alt="image-20220602215841359"></p>
<blockquote>
<p>函数组合（compose）:如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数</p>
<p>函数就像数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果</p>
<p><strong>函数组合默认是从右到左执行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数组合</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">f, g</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(<span class="title function_">g</span>(value));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数一： 返回数组的反转数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> array.<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数二：返回数组的第一个元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数组合会从右向左执行，也就是先执行reverse，再执行first</span></span><br><span class="line"><span class="comment">// 所以之类functionCompose会返回array数组的反转数组的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> functionCompose = <span class="title function_">compose</span>(first, reverse);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">functionCompose</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="lodash-中的组合函数"><a href="#lodash-中的组合函数" class="headerlink" title="lodash 中的组合函数"></a>lodash 中的组合函数</h4><blockquote>
<p>lodash 中的组合函数 flow() 或者 flowRight() , 他们都可以组合多个函数</p>
<p>flow() 是从左到右运行</p>
<p>flowRight()是从右到左运行，使用的更多一些</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&quot;lodash&quot;</span>);</span><br><span class="line"><span class="comment">// lodash中的组合函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = (<span class="params">arr</span>) =&gt; arr.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params">arr</span>) =&gt; arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">toUpper</span> = (<span class="params">s</span>) =&gt; s.<span class="title function_">toUpperCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装lodash中的flowRight</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flowRight</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">    <span class="comment">// reduce(function(previousValue, currentValue, currentIndex, array) &#123; /* ... */ &#125;, initialValue)</span></span><br><span class="line">    <span class="comment">// 这里的fn即args数组中每一个元素，每一个元素都是函数组合中的函数</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">previousValue, fn</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(previousValue);</span><br><span class="line">    &#125;, initialValue);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6写法封装flowRight</span></span><br><span class="line"><span class="comment">// const flowRight = (...args) =&gt; value =&gt; args.reverse().reduce((previousValue, fn) =&gt; fn(previousValue), value)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">flowRight</span>(toUpper, first, reverse);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>([<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>]));</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="19-高阶函数"><a href="#19-高阶函数" class="headerlink" title="19 高阶函数"></a>19 高阶函数</h2><blockquote>
<p>使用高阶函数的意义：</p>
<ul>
<li>抽象可以帮我们屏蔽细节，只需要关注与我们的目标</li>
<li>高阶函数是用来抽象通用的问题</li>
</ul>
</blockquote>
<blockquote>
<p>常用的高阶函数</p>
<p>map、every、some</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</span></span><br><span class="line"><span class="comment">// 封装map方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">array, fn</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> results = []</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array)&#123;</span><br><span class="line">       results.<span class="title function_">push</span>(<span class="title function_">fn</span>(value))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟出一个平方数</span></span><br><span class="line"><span class="keyword">let</span> arrA = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">arrB = <span class="title function_">map</span>(arrA, <span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值</span></span><br><span class="line"><span class="comment">// 封裝every方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">every</span>(<span class="params">array, fn</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array)&#123;</span><br><span class="line">       <span class="keyword">if</span>(!result) <span class="keyword">break</span></span><br><span class="line">       result = <span class="title function_">fn</span>(value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isBelowThreshold</span> = (<span class="params">currentValue</span>) =&gt; currentValue &lt; <span class="number">40</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">30</span>, <span class="number">39</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">13</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">every</span>(array1, isBelowThreshold))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。</span></span><br><span class="line"><span class="comment">// 封裝some方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">some</span>(<span class="params">array, fn</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array)&#123;</span><br><span class="line">       <span class="keyword">if</span>(result) <span class="keyword">break</span></span><br><span class="line">       result = <span class="title function_">fn</span>(value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checks whether an element is even</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">even</span> = (<span class="params">element</span>) =&gt; element % <span class="number">2</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">some</span>(array2, even))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="20-function"><a href="#20-function" class="headerlink" title="20 !function(){}()"></a>20 !function(){}()</h2><p>!function(){} 这种写法，是一种立即执行函数的写法。即 IIFE 等<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>。这种函数在函数定义的地方就直接执行了。</p>
<p>理解 IIFE 设计模式的关键是要认识到，在 ES6 之前，JavaScript 仅具有函数作用域（因此缺少块作用域），并通过闭包内部的引用传递值。ES6 之后情况已不再如此，因为 JavaScript 的 ES6 版本使用 let 和 const 关键字实现了块作用域。</p>
<p>(function(){})()是匿名函数，主要利用函数内的变量作用域，避免产生全局变量，影响整体页面环境，增加代码的兼容性。</p>
<p>(function(){})是一个标准的函数定义，但是没有赋值给任何变量。所以是没有名字的函数，叫匿名函数。没有名字就无法像普通函数那样随时随地调用了，所以在他定义完成后就马上调用他，后面的括号()是运行这个函数的意思。</p>
<p>如下几种写法作用是相同的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)();</span><br><span class="line">~(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)();</span><br><span class="line">-(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)();</span><br><span class="line">+(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">void</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)();</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;)();</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>!function(){}()写法和(function(){})()是相同的</p>
<p>!function(){}()</p>
<p>① 函数后的();表示要执行这个函数；</p>
<p>② 而();要求前面必须是一个表达式。（最后有 js 表达式的定义）。</p>
<p>③ 所以“!”的作用是将 function(){}函数体转为一个函数表达式。</p>
<h2 id="21-with-语句"><a href="#21-with-语句" class="headerlink" title="21 with 语句"></a>21 with 语句</h2><p>with 语句被用于在访问一个对象的属性或方法时避免重复使用指定对象引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">	statements...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>object 指定在 statements 块中没有引用的情况下使用哪个对象引用。<br>在一个连续的程序代码中，如果多次使用某个对象的多个属性或方法，那么只要在 with 关键字后的括号（）中写出该对象的名称，就可以在随后的大括号{}中的程序语句中直接引用该对象的属性名或方法名，不必再在每个属性名或方法名前都加上对象实例名和“.”。</p>
<h2 id="22-eval-函数"><a href="#22-eval-函数" class="headerlink" title="22 eval 函数"></a>22 eval 函数</h2><blockquote>
<p>eval() 函数作用：可以接受一个<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>str 作为参数，并把这个参数作为脚本代码来执行。<br>（如果执行结果是一个值就返回，不是就返回 undefined，如果参数不是一个字符串，则直接返回该参数）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(“<span class="keyword">var</span> a=<span class="number">1</span>”);<span class="comment">//声明一个变量a并赋值1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(“<span class="number">2</span>+<span class="number">3</span>”);<span class="comment">//执行加运算，并返回运算值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(“<span class="title function_">mytest</span>()”);<span class="comment">//执行mytest()函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;&#123;b:2&#125;&quot;</span>);<span class="comment">//声明一个对象。如果想返回此对象，则需要在对象外面再嵌套一层小括如下：eval(&quot;(&#123;b:2&#125;)&quot;);</span></span><br><span class="line"></span><br><span class="line">注意：使用<span class="built_in">eval</span>来解析<span class="title class_">JSON</span>格式字符串的时候，会将&#123;&#125;解析为代码块，而不是对象的字面量</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="函数作用域："><a href="#函数作用域：" class="headerlink" title="函数作用域："></a>函数作用域：</h4><p>eval()函数并不会创建一个新的作用域，并且它的作用域就是它所在的作用域，有时候需要将 eval()函数的作用域设置为全局，当然可以将 eval()在全局作用域中使用，这个时候可以用 window.eval()的方式实现。</p>
</blockquote>
<blockquote>
<h4 id="Function-和-eval-有什么区别？"><a href="#Function-和-eval-有什么区别？" class="headerlink" title="Function 和 eval 有什么区别？"></a>Function 和 eval 有什么区别？</h4><p>共同点：都可以讲字符串转化为 js 代码<br>不同点：Function 创建出来的函数，并不会直接调用，只有当手动去调用创建出来的函数的时候才，eval 把字符串转化为代码后，直接就执行了。</p>
</blockquote>
<h1 id="三、面向对象高级"><a href="#三、面向对象高级" class="headerlink" title="三、面向对象高级"></a>三、面向对象高级</h1><h2 id="01-对象创建模式"><a href="#01-对象创建模式" class="headerlink" title="01 对象创建模式"></a>01 对象创建模式</h2><p>方式一：Object 构造函数模式</p>
<ul>
<li>套路：先创建空 Object 对象，再动态添加属性&#x2F;方法</li>
<li>适用场景：起始时不确定对象内部数据</li>
<li>问题：语句太多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var p = new Object()</span><br><span class="line">p.name = &#x27;Tom&#x27;</span><br><span class="line">p.age = 12</span><br><span class="line">p.setName = function(name)&#123;</span><br><span class="line">this.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：对象字面量模式</p>
<ul>
<li>套路：使用{ }创建对象，同时指定属性&#x2F;方法</li>
<li>适用场景：起始时对象内部数据是确定的</li>
<li>问题：如果创建多个对象，有重复代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>m</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">setName</span>: <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：工厂模式</p>
<ul>
<li>通过工厂函数动态创建对象并返回</li>
<li>适用场景：需要创建多个对象</li>
<li>问题：对象没有一个具体的类型，都是 Object 类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">setName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式四：自定义构造函数模式</p>
<ul>
<li>套路：自定义构造函数，通过 new 创建对象</li>
<li>适用场景：需要创建多个类型确定的对象</li>
<li>问题：每个对象都有相同的数据，浪费内存</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>方法五：构造函数 + 原型的组合模式</p>
<ul>
<li>自定义构造函数，属性在函数中初始化，方法添加到原型上</li>
<li>适用场景：需要创建多个类型确定的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将相关方法添加到原型上</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="02-继承模式"><a href="#02-继承模式" class="headerlink" title="02 继承模式"></a>02 继承模式</h2><h3 id="方式一：原型链继承"><a href="#方式一：原型链继承" class="headerlink" title="方式一：原型链继承"></a>方式一：原型链继承</h3><ul>
<li>步骤</li>
</ul>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象：可以调用父类型的方法</li>
</ol>
<ul>
<li>关键</li>
</ul>
<ol>
<li>子类型的原型为父类型的一个实例对象</li>
</ol>
<p><img src="https://www.hualigs.cn/image/643e5dbe79d28.jpg" alt="image-20190722231650338"></p>
<h3 id="方式二：借用构造函数继承（假的）"><a href="#方式二：借用构造函数继承（假的）" class="headerlink" title="方式二：借用构造函数继承（假的）"></a>方式二：借用构造函数继承（假的）</h3><ul>
<li>步骤</li>
</ul>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造</li>
</ol>
<ul>
<li>关键</li>
</ul>
<ol>
<li>在子类型构造函数中调用 super()调用父类型构造函数</li>
</ol>
<p><img src="https://www.hualigs.cn/image/643e5dfd42a52.jpg" alt="image-20190722233059420"></p>
<h3 id="方式三：原型链-借用构造函数的组合继承"><a href="#方式三：原型链-借用构造函数的组合继承" class="headerlink" title="方式三：原型链 + 借用构造函数的组合继承"></a>方式三：原型链 + 借用构造函数的组合继承</h3><ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用 super()借用父类型构建函数初始化相同属性</li>
</ol>
<p><img src="https://www.hualigs.cn/image/643e5dff554fd.jpg" alt="image-20190723101740129"></p>
<h1 id="四、线程机制与事件机制"><a href="#四、线程机制与事件机制" class="headerlink" title="四、线程机制与事件机制"></a>四、线程机制与事件机制</h1><h2 id="01-进程与线程"><a href="#01-进程与线程" class="headerlink" title="01 进程与线程"></a>01 进程与线程</h2><h3 id="1、进程（process）"><a href="#1、进程（process）" class="headerlink" title="1、进程（process）"></a>1、进程（process）</h3><p>程序一次执行，占有独有的内存一块空间</p>
<p>可以通过 windows 任务管理器查看进程</p>
<h3 id="2、-线程-thread"><a href="#2、-线程-thread" class="headerlink" title="2、 线程 (thread)"></a>2、 线程 (thread)</h3><p>进程内的一个独立执行单元</p>
<p>程序执行的一个完整流程</p>
<p>CPU 的最小调度单元</p>
<h3 id="3、相关知识"><a href="#3、相关知识" class="headerlink" title="3、相关知识"></a>3、相关知识</h3><ul>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程中至少有一个运行的线程：主线程，进程启动后自动创建</li>
<li>一个进程中可以同时运行多个线程，我们会说程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
<li>线程池（thread pool）保存多个线程对象的容器，实现线程对象的反复利用（复用）</li>
</ul>
<h3 id="4、相关问题"><a href="#4、相关问题" class="headerlink" title="4、相关问题"></a>4、相关问题</h3><h4 id="0、为什么-js-要设计成单线程？"><a href="#0、为什么-js-要设计成单线程？" class="headerlink" title="0、为什么 js 要设计成单线程？"></a>0、为什么 js 要设计成单线程？</h4><p>这主要和 js 的用途有关，js 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变</p>
<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h4 id="1、何为多进程与多线程？"><a href="#1、何为多进程与多线程？" class="headerlink" title="1、何为多进程与多线程？"></a>1、何为多进程与多线程？</h4><p>多进程运行：一个应用程序可以同时启动多个实例运行</p>
<p>多线程：在一个进程内，同时有多个线程运行</p>
<h4 id="2、比较单线程与多线程？"><a href="#2、比较单线程与多线程？" class="headerlink" title="2、比较单线程与多线程？"></a>2、比较单线程与多线程？</h4><p>多线程：</p>
<ul>
<li>优点<ul>
<li>能有效提升 CPU 的利用率</li>
</ul>
</li>
<li>缺点<ul>
<li>创建多线程开销</li>
<li>线程键切换开销</li>
<li>死锁与状态同步问题</li>
</ul>
</li>
</ul>
<p>单线程：</p>
<ul>
<li>优点：顺序编程简单易懂</li>
<li>缺点: 效率低</li>
</ul>
<h4 id="3、js-是单线程还是多线程运行？"><a href="#3、js-是单线程还是多线程运行？" class="headerlink" title="3、js 是单线程还是多线程运行？"></a>3、js 是单线程还是多线程运行？</h4><ul>
<li>js 是单线程运行的</li>
<li>但是用 H5 中的 web worker 可以多线程运行</li>
</ul>
<h4 id="4、浏览器运行时单线程还是多线程？"><a href="#4、浏览器运行时单线程还是多线程？" class="headerlink" title="4、浏览器运行时单线程还是多线程？"></a>4、浏览器运行时单线程还是多线程？</h4><p>都是多线程运行的</p>
<h4 id="5、浏览器运行是单进程还是多进程？"><a href="#5、浏览器运行是单进程还是多进程？" class="headerlink" title="5、浏览器运行是单进程还是多进程？"></a>5、浏览器运行是单进程还是多进程？</h4><p>有的是单进程：firefox 、老板 IE</p>
<p>有的是多进程：chrome、新版 IE</p>
<p>浏览器每个进程有多个线程，主要有以下线程</p>
<p>1）GUI 渲染线程:</p>
<p>负责渲染页面，解析 html，css 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。<br>和 js 引擎线程是互斥的，当 js 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 js 任务队列中，等待 js 引擎线程空闲的时候继续执行。</p>
<p>2）js 引擎线程:</p>
<p>单线程工作，负责解析运行 JavaScript 脚本。<br>和 GUI 渲染线程互斥，js 运行耗时过长就会导致页面阻塞。</p>
<p>3）事件触发线程:</p>
<p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 js 引擎处理。</p>
<p>4）定时器触发线程:</p>
<p>浏览器定时计数器并不是由 js 引擎计数的，阻塞会导致计时不准确。<br>开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 js 引擎处理。</p>
<h2 id="02-浏览器内核"><a href="#02-浏览器内核" class="headerlink" title="02 浏览器内核"></a>02 浏览器内核</h2><ul>
<li><p>支撑浏览器运行的最核心的程序</p>
</li>
<li><p>不同浏览器内核可能不一样</p>
<ul>
<li><p>Chrome（webkit 的分支内核 Blink），Safari: webkit</p>
</li>
<li><p>firefox: Gecko</p>
</li>
<li><p>IE:Trident</p>
</li>
<li><p>360,搜狗等国内浏览器：Trident + webkit</p>
</li>
</ul>
</li>
<li><p>内核有很多模块组成：</p>
<ul>
<li>js 引擎模块：负责 js 程序的编译与运行</li>
<li>html、css 文档解析模块：负责页面文本的解析</li>
<li>DOM&#x2F;CSS 模块：负责 DOM&#x2F;CSS 在内存中的相关处理</li>
<li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li>
<li>。。。。</li>
<li>以下是分线程</li>
<li>定时器模块：负责定时器的管理</li>
<li>事件响应模块：负责事件的管理</li>
<li>网络请求模块：负责 ajax 请求</li>
</ul>
</li>
</ul>
<h2 id="03-定时器引发的思考"><a href="#03-定时器引发的思考" class="headerlink" title="03 定时器引发的思考"></a>03 定时器引发的思考</h2><h3 id="1、定时器真的是定时执行的嘛？"><a href="#1、定时器真的是定时执行的嘛？" class="headerlink" title="1、定时器真的是定时执行的嘛？"></a>1、定时器真的是定时执行的嘛？</h3><p>定时器并不能保证真正定时执行</p>
<p>一般会延迟一丁点（可以接受），也有可能延迟很长时间（不能接受）</p>
<h3 id="2、定时器回调函数是在分线程执行的嘛？"><a href="#2、定时器回调函数是在分线程执行的嘛？" class="headerlink" title="2、定时器回调函数是在分线程执行的嘛？"></a>2、定时器回调函数是在分线程执行的嘛？</h3><p>在主线程执行的，js 是单线程的</p>
<h2 id="04-JS-是单线程的"><a href="#04-JS-是单线程的" class="headerlink" title="04 JS 是单线程的"></a>04 JS 是单线程的</h2><h3 id="1、如何证明-js-执行是单线程的？"><a href="#1、如何证明-js-执行是单线程的？" class="headerlink" title="1、如何证明 js 执行是单线程的？"></a>1、如何证明 js 执行是单线程的？</h3><ul>
<li>setTimeout()的回调函数是在主线程执行的</li>
<li>定时器回调函数只有在运行栈中的代码全部执行完毕之后才有可能执行</li>
</ul>
<h3 id="2、为什么-js-要用单线程模式，而不用多线程？"><a href="#2、为什么-js-要用单线程模式，而不用多线程？" class="headerlink" title="2、为什么 js 要用单线程模式，而不用多线程？"></a>2、为什么 js 要用单线程模式，而不用多线程？</h3><ul>
<li>js 的单线程和它的用途有关</li>
<li>作为浏览器脚本语言，js 的主要用途是与用户互动，以及操作 DOM</li>
<li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li>
</ul>
<h3 id="3、代码的分类："><a href="#3、代码的分类：" class="headerlink" title="3、代码的分类："></a>3、代码的分类：</h3><ul>
<li>初始化代码</li>
<li>回调代码 （异步执行）</li>
</ul>
<h3 id="4、js-引擎执行代码的基本流程"><a href="#4、js-引擎执行代码的基本流程" class="headerlink" title="4、js 引擎执行代码的基本流程"></a>4、js 引擎执行代码的基本流程</h3><ul>
<li><p>先执行初始化代码：包含一些特别的代码</p>
<ul>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送 ajax 请求</li>
</ul>
</li>
<li><p>后面在某个时刻才会执行回调代码</p>
</li>
</ul>
<h2 id="05-事件循环模型"><a href="#05-事件循环模型" class="headerlink" title="05 事件循环模型"></a>05 事件循环模型</h2><p><img src="https://www.hualigs.cn/image/643e5e2fd8f06.jpg" alt="image-20190723130215072"></p>
<p><img src="https://www.hualigs.cn/image/643e5e351e084.jpg" alt="image-20190723131807670"></p>
<h4 id="单线程执行数据，多线程处理事件"><a href="#单线程执行数据，多线程处理事件" class="headerlink" title="单线程执行数据，多线程处理事件"></a>单线程执行数据，多线程处理事件</h4><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队<br>宏列队:用来保存待执行的宏任务(回调),比如:定时器回调&#x2F;DOM 事件回调&#x2F;ajax 回调<br>微列队:用来保存待执行的微任务(回调),比如:promise 的回调&#x2F;MutationObserver 的回调<br>JS 执行时会区别这 2 个队列<br>JS 引擎首先必须先执行所有的初始化同步任务代码<br>每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行。当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。<br>引入微任务的初衷是为了解决异步回调的问题</p>
<h4 id="macrotask（宏任务）"><a href="#macrotask（宏任务）" class="headerlink" title="macrotask（宏任务）"></a>macrotask（宏任务）</h4><p>在浏览器端，其可以理解为该任务执行完后，在下一个 macrotask 执行开始前，浏览器可以进行页面渲染。触发 macrotask 任务的操作包括：dom 事件回调，ajax 回调，定时器回调<br>script(整体代码)<br>setTimeout、setInterval、setImmediate<br>I&#x2F;O、UI 交互事件<br>postMessage、MessageChannel</p>
<h4 id="microtask（微任务）"><a href="#microtask（微任务）" class="headerlink" title="microtask（微任务）"></a>microtask（微任务）</h4><p>可以理解为在 macrotask 任务执行后，页面渲染前立即执行的任务。触发 microtask 任务的操作包括：<br>Promise 回调：Promise.then<br>Mutation 回调：MutationObserver<br>process.nextTick(Node 环境)</p>
<h4 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h4><p><img src="https://www.hualigs.cn/image/643e5e64a2f62.jpg" alt="image-20190723133418951"></p>
<p><img src="https://www.hualigs.cn/image/643e5e65a7c8d.jpg" alt="image-20190723133633643"></p>
<h2 id="06-相关重要概念"><a href="#06-相关重要概念" class="headerlink" title="06 相关重要概念"></a>06 相关重要概念</h2><h3 id="1、执行栈"><a href="#1、执行栈" class="headerlink" title="1、执行栈"></a>1、执行栈</h3><p>execution stack</p>
<p>所有代码都是在此空间中执行的</p>
<h3 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h3><ul>
<li>browser core</li>
<li>js 引擎模块（在主线程处理）</li>
<li>其他模块（在主&#x2F;分线程处理）</li>
<li>运行原理图</li>
</ul>
<h3 id="3、任务队列-task-queue"><a href="#3、任务队列-task-queue" class="headerlink" title="3、任务队列 task queue"></a>3、任务队列 task queue</h3><h3 id="4、消息队列-message-queue"><a href="#4、消息队列-message-queue" class="headerlink" title="4、消息队列 message queue"></a>4、消息队列 message queue</h3><h3 id="5、事件队列-event-queue"><a href="#5、事件队列-event-queue" class="headerlink" title="5、事件队列 event queue"></a>5、事件队列 event queue</h3><h3 id="6、事件轮询-event-loop"><a href="#6、事件轮询-event-loop" class="headerlink" title="6、事件轮询 event loop"></a>6、事件轮询 event loop</h3><p>从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）</p>
<h3 id="7、事件驱动模型-event-driven-interaction-model"><a href="#7、事件驱动模型-event-driven-interaction-model" class="headerlink" title="7、事件驱动模型 event-driven interaction model"></a>7、事件驱动模型 event-driven interaction model</h3><h3 id="8、请求响应模型-request-response-model"><a href="#8、请求响应模型-request-response-model" class="headerlink" title="8、请求响应模型 request-response model"></a>8、请求响应模型 request-response model</h3><h2 id="07-H5-Web-Workers"><a href="#07-H5-Web-Workers" class="headerlink" title="07 H5 Web Workers"></a>07 H5 Web Workers</h2><ol>
<li><p>H5 规范提供了 js 分线程的实现，取名为：Web Workers，</p>
<p>我们可以将一些大计算量的代码交由 web worker 运行而不冻结用户界面，但是子线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JavaScript 单线程的本质</p>
</li>
<li><p>相关 API</p>
<ul>
<li>Worker: 构造函数，加载分线程执行的 js 文件</li>
<li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li>
<li>Worker.prototype.postMessage: 象另一个线程发送消息</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li><p>慢</p>
<p>Worker 内代码不能操作 DOM（更新 UI）</p>
</li>
<li><p>不能跨域加载 JS</p>
</li>
<li><p>不是每个浏览器都支持这个特性</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://www.hualigs.cn/image/643e5e8d84955.jpg" alt="image-20190723164631070"></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>ES5</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx、Ngrok解决线上代理本地</title>
    <url>/post/1d7850e6.html</url>
    <content><![CDATA[<h1 id="线上代理本地"><a href="#线上代理本地" class="headerlink" title="线上代理本地"></a>线上代理本地</h1><blockquote>
<p>线上代理本地是通过网络将本地服务器或应用公开给互联网访问的过程，通常用于开发和调试目的。通过这种方式，开发者可以让远程用户或其他线上服务直接访问本地运行的服务。</p>
</blockquote>
<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><ul>
<li><a href="https://ngrok.com/">Ngrok</a> 是最流行的工具之一，它通过创建一个安全的隧道，将本地服务器公开到互联网上。</li>
<li><a href="https://www.nginx-cn.net/">Nginx</a> 高级负载均衡器、Web服务器、反向代理</li>
</ul>
<h2 id="Ngrok"><a href="#Ngrok" class="headerlink" title="Ngrok"></a>Ngrok</h2><p><code>ngrok</code> 是最流行的工具之一，它通过创建一个安全的隧道，将本地服务器公开到互联网上</p>
<p>使用 ngrok 暴露本地端口 启动 ngrok，将本地 8080 端口暴露给外网。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ngrok http 8080 <span class="comment"># 8080 是你本地启动服务的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动后会提供一个公网 URL，例如 https://abc.ngrok.io，其他人或服务可以通过这个地址访问你的本地服务</span></span><br></pre></td></tr></table></figure>

<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure>

<p>nginx 基础命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动命令</span></span><br><span class="line"><span class="built_in">sudo</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启命令</span></span><br><span class="line"><span class="built_in">sudo</span> nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="built_in">sudo</span> nginx -s quit  或者直接: killall nginx.</span><br><span class="line"></span><br><span class="line"><span class="comment">#  检查是否已经启动成功</span></span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>修改 <code>nginx.conf</code> : <code>sudo nano /usr/local/etc/nginx/nginx.conf</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://&lt;本地IP&gt;:8080;  <span class="comment"># 指向本地服务的IP和端口</span></span><br><span class="line">        proxy_connect_timeout 600;</span><br><span class="line">        proxy_read_timeout 600;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>修改 <code>host</code> 命令: <code>sudo nano /etc/hosts</code></p>
<p>清除 <code>DNS缓存</code> 命令: <code>sudo killall -HUP mDNSResponder</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#127.0.0.1         example.com</span></span><br><span class="line">127.0.0.1         localhost</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置完之后，浏览器上 <code>http://example.com</code> 就是访问的 <code>http://&lt;本地IP&gt;:8080</code></p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript用法</title>
    <url>/post/86c0ae8.html</url>
    <content><![CDATA[<blockquote>
<p>记录 TypeScript 用法</p>
</blockquote>
<h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，null 和 undefined 是所有类型的子类型</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组定义方式1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">number</span>[] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">100</span>, <span class="number">200</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>在定义数组的时候，类型和数据的个数一开始就已经限定了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: [<span class="built_in">string</span>,<span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="string">&#x27;小甜甜&#x27;</span>,<span class="number">100</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3[<span class="number">1</span>].<span class="title function_">toFixed</span>(<span class="number">2</span>)) toFixed是保留小数点后几位的</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Color的枚举类型的变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">color</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">red</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型可以手动编号</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  red = <span class="number">1</span>,</span><br><span class="line">  green,</span><br><span class="line">  blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Color</span>[<span class="number">3</span>]); <span class="comment">//&#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>想要为哪些在编程阶段还不清楚类型的变量指定一个类型。</p>
<p>这些值可能来自于动态的内容，比如来自用户输入或第三方代码库</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notsure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notsure = <span class="string">&quot;maybe a string&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，void 类型和 any 类型相反，它表示没有任何类型，当一个函数没有返回值，通常看见其返回值类型为 void</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般用来说明函数的返回值不能是undefined和null之外的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn()&quot;</span>);</span><br><span class="line">  <span class="comment">//return undefined</span></span><br><span class="line">  <span class="comment">//return null</span></span><br><span class="line">  <span class="comment">//return 1 //error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>表示非原始类型，除了 number、string、boolean 之外的类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"><span class="attr">obj</span>: <span class="built_in">object</span></span>): <span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2(0)&quot;</span>, obj);</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="comment">//return undefined</span></span><br><span class="line">  <span class="comment">//return null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="联合类型-（union-types"><a href="#联合类型-（union-types" class="headerlink" title="联合类型 （union types)"></a>联合类型 （union types)</h3><p>标识取值可以为多种类型中的一种</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString2</span>(<span class="params">x;<span class="title class_">String</span>|<span class="built_in">number</span></span>):<span class="built_in">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里这里传String,或者number类型给toString2</span></span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言可以告诉编译器，已经做了必须的检查，类型断言好比其他语言中的类型转换，但是不进行特殊的数据检查和解构</p>
<p>类型断言的语法方式 1：&lt;类型&gt;变量名</p>
<p>类型断言的语法方式 2 值 as 类型</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getString</span>(<span class="params"><span class="attr">str</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;str).<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">//这里断言了str是String类型</span></span><br><span class="line">    <span class="comment">//return (&lt;string&gt;str),length //写法一</span></span><br><span class="line">    <span class="keyword">return</span> (str <span class="keyword">as</span> <span class="title class_">String</span>).<span class="property">length</span>; <span class="comment">//写法二</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//此时说明str是number类型</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">toString</span>().<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>没有明确的指定类型的时候推测出一个类型</p>
<p>有两种情况：</p>
<p>1、定义变量时赋值了，推断为对应的类型</p>
<p>2、定义变量时没有赋值，推断为 any 类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> txt1 = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt1); <span class="comment">//类型推断为number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> txt2; <span class="comment">//类型推断为any</span></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是对象的状态(属性)和行为(方法)的抽象</p>
<p>接口时一种类型，一种规范，一种规则，一个能力，一种约束</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="comment">//id是只读的,是number类型，相比较于const，const是修饰变量的，而readonly是修饰属性用</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">//在属性名sex后面加上？表示这个属性是可有可无的</span></span><br><span class="line">  sex?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="函数调用签名"><a href="#函数调用签名" class="headerlink" title="函数调用签名"></a>函数调用签名</h3><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名</p>
<p>它就像是一个只有参数列表和返回值类型的函数定义，参数列表里的每个参数都需要名字和类型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个接口，用来作为某个函数的类型使用</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISearchFunc</span> &#123;</span><br><span class="line">	<span class="comment">//定义一个调用签名</span></span><br><span class="line">	（<span class="attr">source</span>:<span class="built_in">string</span>, <span class="attr">subString</span>:<span class="built_in">string</span>）:<span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个函数，该类型就是上面定义的接口</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">searchString</span>:<span class="title class_">ISearchFunc</span> = <span class="keyword">function</span>(<span class="params"><span class="attr">source</span>:<span class="built_in">string</span>, <span class="attr">subString</span>:<span class="built_in">string</span></span>):<span class="built_in">boolean</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.<span class="title function_">search</span>(subString) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类类型 ：类的类型可以通过接口来实现</span></span><br><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IFly</span>&#123;</span><br><span class="line">	<span class="comment">//该方法没有任何的实现(方法中什么都没有)</span></span><br><span class="line">	<span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwim</span>&#123;</span><br><span class="line">	<span class="title function_">swim</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类，这个类的类型就是上面定义的接口, 实际上也可以理解为IFly接口约束了当前的这个Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">IFly</span>,<span class="title class_">ISwim</span>&#123;</span><br><span class="line">	<span class="comment">//实现接口中的方法</span></span><br><span class="line">	<span class="title function_">fly</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>。<span class="title function_">log</span>(”I can fly“)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">swim</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I can swim&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person.<span class="title function_">fly</span>()</span><br><span class="line">person.<span class="title function_">swim</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：类可以通过接口的方式，来定义当前这个类的类型，</span></span><br><span class="line"><span class="comment">//类可以实现一个接口，类可以实现多个接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口可以继承其他多个接口</span></span><br><span class="line">imterface <span class="title class_">IMyFlyAndSwim</span> <span class="keyword">extends</span> <span class="title class_">IFly</span>，<span class="title class_">ISwim</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口和接口之间叫继承（使用的是extends关键字），类和接口之间叫实现（implements）</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>A 类继承了 B 类，A 类叫子类，B 类叫基类</p>
<p>子类 （派生类）</p>
<p>基类 （超类、父类）</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>父类型的引用指向了子类型的对象，不同类型的对象针对相同的方法，产生了不同的行为</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>getter 和 setter</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>static 修饰</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract</p>
<p>抽象类：包含抽象方法（抽象方法一般没有任何的具体内容的实现），也可以包含实例方法，抽象类是不能被实例化，为了让子类进行实例化及实现</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">//抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//不能有具体实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常 Java 类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通 Java 类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main 方法</td>
<td>抽象方法可以有 main 方法并且我们可以运行它</td>
<td>接口没有 main 方法，因此我们不能运行它。（java8 以后接口可以有 default 和 static 方法，所以可以运行 main 方法）</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法：函数声明，命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>:<span class="built_in">string</span></span>):<span class="built_in">string</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：函数表达式，匿名函数 (简写)</span></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="keyword">function</span> (<span class="params"><span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span></span>):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：匿名函数的完整写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add2</span>: (<span class="function">(<span class="params"><span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span></span>)=&gt;</span><span class="built_in">number</span> = <span class="keyword">function</span>(<span class="params"><span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span></span>):<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数与默认参数"><a href="#可选参数与默认参数" class="headerlink" title="可选参数与默认参数"></a>可选参数与默认参数</h3><p>可选参数：函数在声明的时候，内部的参数使用了？进行修饰，那么就表示该参数可以传入也可以不用传入，叫可选参数</p>
<h3 id="剩余参数-rest-参数"><a href="#剩余参数-rest-参数" class="headerlink" title="剩余参数 rest 参数"></a>剩余参数 rest 参数</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...args:string[] ---剩余的参数，放在了一个字符串的数组中，args里面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMSg</span>(<span class="params"><span class="attr">str</span>: <span class="built_in">string</span>, ...<span class="attr">args</span>: sting[]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">//a</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">//b,c,d,e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showMsg</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数名字相同，函数的参数及个数不同</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在定义函数、接口、类的时候，不能预先确定要使用的数据类型，而是在使用时候确定</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getArr4&lt;T&gt;(<span class="attr">value</span>: T, <span class="attr">count</span>: <span class="built_in">number</span>): T[] &#123;</span><br><span class="line">  <span class="comment">//根据数据value和数量产生一个数组</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个泛型参数的函数：函数中有多个泛型的参数</span></span><br><span class="line"><span class="keyword">function</span> getMsg&lt;K, V&gt;(<span class="attr">value1</span>: K, <span class="attr">value2</span>: V): [K, V] &#123;</span><br><span class="line">  <span class="keyword">return</span> [value1, value2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IBase</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">Array</span>&lt;T&gt;;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params"><span class="attr">t</span>: T</span>) =&gt;</span> T;</span><br><span class="line">  <span class="attr">getUserId</span>: <span class="function">(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//默认的属性的值的类型是泛型类型</span></span><br><span class="line">  <span class="attr">defaultValue</span>: T;</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params"><span class="attr">x</span>: T, <span class="attr">y</span>: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型约束</span></span><br><span class="line"><span class="comment">//如果我们直接对一个泛型参数取length属性，会报错，因为这个泛型根本不知道这个属性</span></span><br><span class="line"><span class="comment">//定义一个接口，用来约束将来的某个类型中必须要有length这个属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">  <span class="comment">//接口中有一个属性length</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">x</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全，接口提示等功能，什么是声明语句</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入第三方的库jQuery</span></span><br><span class="line"><span class="keyword">import</span> jQuery <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="comment">//定义操作</span></span><br><span class="line"><span class="comment">//声明文件：把声明语句放到一个单独的文件（jQuery.d.ts）中，ts会自动解析到项目中所有声明文件</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params"><span class="attr">selector</span>: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载声明文件： npm install @types/jquery --save-dev</span></span><br></pre></td></tr></table></figure>

<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ECMAScript的内置对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>)</span><br><span class="line">..</span><br><span class="line"><span class="title class_">Number</span></span><br><span class="line"><span class="title class_">String</span></span><br><span class="line"><span class="title class_">Date</span></span><br><span class="line"><span class="title class_">RegExp</span></span><br><span class="line"><span class="title class_">Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BOM和DOM的内置对象</span></span><br><span class="line"><span class="title class_">Window</span></span><br><span class="line"><span class="title class_">Document</span></span><br><span class="line"><span class="title class_">HTMLElement</span></span><br><span class="line"><span class="title class_">DocumentFragment</span></span><br><span class="line"><span class="title class_">Event</span></span><br><span class="line"><span class="title class_">NodeList</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Volta</title>
    <url>/post/750210a8.html</url>
    <content><![CDATA[<h1 id="Volta"><a href="#Volta" class="headerlink" title="Volta"></a><a href="https://volta.sh/">Volta</a></h1><blockquote>
<p>Volta 是一个用于管理 Node.js 版本和 JavaScript 工具的工具，可以帮助你在项目中轻松切换 Node.js 版本。可以为每个项目设置特定的 Node.js 版本，切换时非常迅速。在项目目录中运行时，Volta 会自动使用该项目指定的 Node.js 版本。在 Windows、macOS 和 Linux 上都能使用。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl https://get.volta.sh | bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>链接: <a href="https://pan.baidu.com/s/1MgKLQ8cbm3tshTdAtBPQHA">https://pan.baidu.com/s/1MgKLQ8cbm3tshTdAtBPQHA</a></p>
<p>提取码: <code>qzx5</code></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 版本/查看是否安装成功</span></span><br><span class="line">volta -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局Node，默认使用的版本</span></span><br><span class="line">volta install node@14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前项目需要使用 node 的版本，在 `package.json` 目录下 执行，正常如果你 package.json 有 volta 配置，它自动会安装对应版本</span></span><br><span class="line">volta pin node@16</span><br><span class="line">volta pin pnpm</span><br><span class="line">volta pin yarn@1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本 node | pnpm | npm</span></span><br><span class="line">volta list node</span><br><span class="line">volta list pnpm</span><br><span class="line">volta list npm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载对应版本</span></span><br><span class="line"><span class="built_in">cd</span> ~/.volta/tools/image  <span class="comment"># 进入 tools 在 cd 进入 node</span></span><br><span class="line"><span class="built_in">cd</span> node <span class="built_in">rm</span> -rf 12.0.0    <span class="comment"># 卸载 node 12.0.0 版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm 查看镜像</span></span><br><span class="line">pnpm config get registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置淘宝镜像</span></span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>window 可能会碰到 执行 volta install node@16 或者其他版本 会失败</p>
<p>报的是 <code>download error</code>, 原因就是网络问题，hooks 换源</p>
<p>进入下面文件：</p>
<p><img src="/img/volta-config.png" alt="image-volta-config"></p>
<p>hooks.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/index.json&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;distro&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://mirrors.cloud.tencent.com/nodejs-release/v&#123;&#123;version&#125;&#125;/node-v&#123;&#123;version&#125;&#125;-&#123;&#123;os&#125;&#125;-x64.zip&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>配置完成 就 ok 了</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>桂林游玩攻略</title>
    <url>/post/bccf8553.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>桂林</tag>
      </tags>
  </entry>
</search>
